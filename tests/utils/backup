#!/bin/sh
# aside from this initial boilerplate, this is actually -*- scheme -*- code

# This test assumes `TESTS_ENVIRONMENT' set up Guile's search path
# correctly.

exec ${GUILE:-guile} -L "$top_builddir/utils" \
  -l "$0" -c "(apply $main (cdr (command-line)))" "$@"
!#
;;; Copyright (C) 2012  Ludovic Courtès <ludo@gnu.org>
;;;
;;; Libchop is free software: you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation, either version 3 of the License, or
;;; (at your option) any later version.
;;;
;;; Libchop is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with libchop.  If not, see <http://www.gnu.org/licenses/>.

(setenv "XDG_CACHE_HOME"
        (string-append (getcwd) "/backup-cache"))

(define-module (backup-test)
  #:use-module (chop-backup)
  #:use-module (chop tests)
  #:use-module (chop objects)
  #:use-module (chop streams)
  #:use-module (chop stores)
  #:use-module (chop indexers)
  #:use-module (ice-9 ftw)
  #:use-module (ice-9 regex)
  #:use-module (ice-9 match)
  #:use-module (ice-9 format)
  #:use-module (srfi srfi-1)
  #:use-module (srfi srfi-26)
  #:use-module (srfi srfi-34)
  #:use-module (srfi srfi-35)
  #:use-module (srfi srfi-64)
  #:use-module (rnrs bytevectors)
  #:use-module (rnrs io ports))

;; Some tests check error messages.
(setlocale LC_ALL "C")


;;;
;;; Helpers.
;;;

(define (temporary-file-name)
  (format #f "backup-test-~x-~x" (getpid) (car (gettimeofday))))

(define %top-srcdir
  (or (getenv "top_srcdir")
      (error "please define $top_srcdir")))

(define %test-dir
  (temporary-file-name))

(mkdir %test-dir)

(define %include-dir
  (string-append %top-srcdir "/include"))

(define (directory-entry=stat? entry name stat)
  "Return #t when ENTRY is equivalent to NAME + STAT."
  (and (string=? (basename name)
                 (directory-entry-name entry))
       (= (stat:perms stat)
          (directory-entry-permissions entry))
       (= (stat:size stat)
          (directory-entry-size entry))
       (eq? (stat:type stat)
            (directory-entry-kind entry))))


(test-begin "run-storage-pipeline")

(test-assert "retrievable"
  (with-temporary-store
   (lambda (store)
     (let* ((bv     (make-random-bytevector (random-file-size)))
            (input  (mem-stream-open bv))
            (index  (run-storage-pipeline %default-storage-pipeline
                                          input store))
            (tuple  (pipeline-index-handle->tuple %default-storage-pipeline
                                                  index))
            (retr   (index-tuple->retriever tuple))
            (output (get-bytevector-all (retr store))))
       (bytevector=? bv output)))))

(test-assert "verify: ok"
  (with-temporary-store
   (lambda (store)
     (let* ((bv     (make-random-bytevector (random-file-size)))
            (input  (mem-stream-open bv))
            (index  (run-storage-pipeline %default-storage-pipeline
                                          input store))
            (tuple  (pipeline-index-handle->tuple %default-storage-pipeline
                                                  index))
            (verify (index-tuple->verifier tuple)))
       (eq? 'ok (verify store))))))

(test-assert "verify: missing"
  (with-temporary-store
   (lambda (store)
     (let* ((bv     (make-random-bytevector (random-file-size)))
            (input  (mem-stream-open bv))
            (index  (run-storage-pipeline %default-storage-pipeline
                                          input store))
            (tuple  (pipeline-index-handle->tuple %default-storage-pipeline
                                                  index))
            (verify (index-tuple->verifier tuple)))
       ;; XXX: Use `block-indexer-delete-block' when it exists.
       (store-delete-block store (index-handle->block-key index))
       (eq? 'missing (verify store))))))

(test-assert "repair root block"
  ;; Same as above, and repair the root block.
  (with-temporary-store
   (lambda (store)
     (let* ((bv     (make-random-bytevector (random-file-size)))
            (input  (mem-stream-open bv))
            (index  (run-storage-pipeline %default-storage-pipeline
                                          input store))
            (tuple  (pipeline-index-handle->tuple %default-storage-pipeline
                                                  index))
            (verify (index-tuple->verifier tuple)))
       ;; XXX: Use `block-indexer-delete-block' when it exists.
       (store-delete-block store (index-handle->block-key index))
       (and (eq? 'missing (verify store))
            (object=? (run-storage-pipeline %default-storage-pipeline
                                            (mem-stream-open bv) store)
                      index)
            (eq? 'ok (verify store)))))))

(test-end)


(test-begin "run-storage-pipeline-recursive")

(test-assert "unchanged dir ⇒ same tuple"
  (with-temporary-store
   (lambda (store)
     (let ((t1 (run-storage-pipeline/recursive (const %default-storage-pipeline)
                                               %include-dir
                                               store))
           (t2 (run-storage-pipeline/recursive (const %default-storage-pipeline)
                                               %include-dir
                                               store))
           (t3 (run-storage-pipeline/recursive (lambda (file stat)
                                                 %default-storage-pipeline)
                                               %include-dir
                                               store)))
       (and (pair? t1) (equal? t1 t2) (equal? t2 t3))))))

(test-assert "EACCES on file"
  (with-temporary-store
   (lambda (store)
     (with-file-tree %test-dir (directory "root"
                                          (("a") ("b") ("c" #o000)))
       (guard (c ((pipeline-storage-error? c)
                  (and (eq? (pipeline-error-pipeline c)
                            %default-storage-pipeline)
                       (string=? "c"
                                 (basename (pipeline-storage-error-input c)))
                       (= EACCES (pipeline-error-libchop-error c)))))
         (run-storage-pipeline/recursive (const %default-storage-pipeline)
                                         (string-append %test-dir "/root")
                                         store)

         ;; Never reached.
         #f)))))

(test-assert "EACCES on sub-directory"
  (with-temporary-store
   (lambda (store)
     (with-file-tree %test-dir (directory "root"
                                          (("a") ("b")
                                           (directory "subdir" #o000
                                                      (("c") ("d")))))
       (let ((port (open-output-string)))
         (with-error-to-port port
           (lambda ()
             (run-storage-pipeline/recursive (const %default-storage-pipeline)
                                             (string-append %test-dir "/root")
                                             store)))

         (string-match "subdir.*ignored" (get-output-string port)))))))

(test-assert "read-directory"
  (with-temporary-store
   (lambda (store)
     (with-file-tree %test-dir (directory "root"
                                          (("a" #o640) ("b" #o754)
                                           ("c" #o464)
                                           ("d" -> "a")))
       (let* ((dir   (string-append %test-dir "/root"))
              (tuple (run-storage-pipeline/recursive
                      (const %default-storage-pipeline) dir store))
              (retr  (index-tuple->retriever tuple)))
         (let ((d (read-directory (retr store))))
           (and (directory? d)
                ;;(not (directory-previous-version d))
                (let ((e (sort (directory-entries d)
                               (lambda (e1 e2)
                                 (string< (directory-entry-name e1)
                                          (directory-entry-name e2))))))
                  (fold (lambda (n+s e r)
                          (match n+s
                            ((name . stat)
                             (and r (directory-entry=stat? e name stat)))))
                        #t
                        (sort (file-system-fold (const #t) ; entries of DIR
                                                alist-cons
                                                (lambda (n s r) r)
                                                (lambda (n s r) r)
                                                (lambda (n s r) r)
                                                (lambda (n s e r) r)
                                                '()
                                                dir)
                              (lambda (e1 e2)
                                (string< (car e1) (car e2))))
                        e)))))))))

(test-end)


(gc) ;; stress the GC

(rmdir %test-dir)

;; rm -rf $XDG_CACHE_HOME
(file-system-fold (lambda (dir stat result) #t)   ; enter?
                  (lambda (file stat result)      ; leaf
                    (delete-file file))
                  (lambda (dir stat result)       ; down
                    result)
                  (lambda (dir stat result)       ; up
                    (rmdir dir))
                  (lambda (dir stat result)       ; skip
                    result)
                  (lambda (dir stat errno result) ; error
                    #f)
                  #t
                  (getenv "XDG_CACHE_HOME"))

(exit (= (test-runner-fail-count (test-runner-current)) 0))

;;; Local Variables:
;;; eval: (put 'test-assert 'scheme-indent-function 1)
;;; End:
