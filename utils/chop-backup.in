#!/bin/sh
# aside from this initial boilerplate, this is actually -*- scheme -*- code
main="(module-ref (resolve-module '(chop-backup)) 'chop-backup)"
prefix="@prefix@"
exec ${GUILE:-@GUILE@} -L "@guilemoduledir@" \
  -l "$0" -c "(apply $main (cdr (command-line)))" "$@"
!#
;;; Copyright (C) 2011, 2012  Ludovic Court√®s <ludo@gnu.org>
;;;
;;; Libchop is free software: you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation, either version 3 of the License, or
;;; (at your option) any later version.
;;;
;;; Libchop is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with libchop.  If not, see <http://www.gnu.org/licenses/>.

(define-module (chop-backup)
  #:use-module (chop)
  #:use-module (srfi srfi-1)
  #:use-module (srfi srfi-9)
  #:use-module (srfi srfi-11)
  #:use-module (srfi srfi-19)
  #:use-module (srfi srfi-26)
  #:use-module (srfi srfi-34)
  #:use-module (srfi srfi-35)
  #:use-module (srfi srfi-37)
  #:use-module (srfi srfi-60)
  #:use-module (rnrs bytevectors)
  #:use-module ((rnrs io ports) #:select (get-bytevector-n! put-bytevector))
  #:use-module (ice-9 ftw)
  #:use-module (ice-9 match)
  #:use-module (ice-9 vlist)
  #:use-module (ice-9 regex)
  #:use-module (ice-9 format)
  #:export (pipeline?
            make-pipeline
            pipeline-stream-filters
            pipeline-chopper
            pipeline-indexer
            pipeline-block-indexer
            pipeline-store-filters

            &pipeline-error
            pipeline-error?
            pipeline-error-pipeline
            pipeline-error-libchop-error

            &pipeline-storage-error
            pipeline-storage-error?
            pipeline-storage-error-input

            run-storage-pipeline
            run-storage-pipeline/recursive
            pipeline-index-handle->tuple
            index-tuple->retriever
            index-tuple->verifier

            %default-storage-pipeline

            directory?
            directory-entries
            directory-previous-version
            read-directory
            write-directory

            directory-entry?
            directory-entry-kind
            directory-entry-mtime
            directory-entry-name
            directory-entry-permissions
            directory-entry-size
            directory-entry-tuple

            chop-backup))

;;; Commentary:
;;;
;;; This modules provides tools to store (encrypted) backups of whole file
;;; hierarchies.
;;;
;;; Code:


;;;
;;; User interface.
;;;

(define _ gettext)
(define N_ ngettext)

(define-syntax warn
  (syntax-rules ()
    ((_ message args ...)
     (begin
      (format (current-error-port) message args ...)
      (newline (current-error-port))))))

(if (not (string=? "@PACKAGE_VERSION@" (libchop-version)))
    (warn (_ "written for libchop @PACKAGE_VERSION@ but using ~a!")
          (libchop-version)))


;;;
;;; Persistent backup state.
;;;

(define (cache-directory)
  (string-append (or (getenv "XDG_CACHE_HOME")
                     (string-append (getenv "HOME") "/.cache"))
                 "/chop/backup"))

(define (mkdir-p dir)
  "Create directory DIR and all its ancestors."
  (define absolute?
    (string-prefix? "/" dir))

  (define not-slash
    (char-set-complement (char-set #\/)))

  (let loop ((components (string-tokenize dir not-slash))
             (root       (if absolute?
                             ""
                             ".")))
    (or (null? components)
        (let ((path (string-append root "/" (car components))))
          (catch 'system-error
            (lambda ()
              (mkdir path)
              (loop (cdr components) path))
            (lambda args
              (if (= EEXIST (system-error-errno args))
                  (loop (cdr components) path)
                  (apply throw args))))))))

(or (file-exists? (cache-directory))
    (mkdir-p (cache-directory)))

(define (cache-file name)
  (string-append (cache-directory) "/" name))

(define %file-index-mapping
  ;; Map (INODE . DEVICE) to (MTIME . INDEX-TUPLE).
  (file-based-block-store-open (lookup-class "fs_block_store")
                               (cache-file "file-index-mapping")
                               (logior O_CREAT O_RDWR)
                               #o600))

(define %recent-backups-file
  ;; A cache containing a list of file/tuple pairs.
  (cache-file "recent-backups"))

(define %max-recent-backup-tuples
  ;; Maximum number of tuples kept for each directory.
  50)

(define (save-backup-tuple dir tuple)
  "Append the DIR/TUPLE pair to the recent-backups cache file."
  (define (strip tuples)
    (let* ((tuples (delete-duplicates tuples))
           (len    (length tuples)))
      (if (<= len %max-recent-backup-tuples)
          tuples
          (take tuples %max-recent-backup-tuples))))

  (let ((backups (if (file-exists? %recent-backups-file)
                     (call-with-input-file %recent-backups-file read)
                     '())))
    (call-with-output-file %recent-backups-file
      (lambda (p)
        (let ((prev (or (assoc-ref backups dir) '())))
         (write (alist-cons dir (strip (cons tuple prev))
                            (alist-delete dir backups))
                p))))))

(define (recent-backups)
  "Return a list of directory/tuples pairs representing recent backups."
  (if (file-exists? %recent-backups-file)
      (call-with-input-file %recent-backups-file read)
      '()))

(define (most-recent-backup-tuple store)
  "Return the file/tuple pair corresponding to the most recent backup
available in STORE."
  (any (match-lambda
         ((dir tuples ...)
          (and=> (find (compose (cut indexed-block-exists? <> store)
                                (match-lambda ((_ index _) index)))
                       tuples)
                 (cut cons dir <>))))
        (recent-backups)))


;;;
;;; Directory meta-data.
;;;

;; We want to (1) allow efficient processing of directory data, and (2)
;; decouple the serialized format of directories from the in-memory
;; representation.  Thus, we use record types for the in-memory
;; representations, and s-exps only for the external representation.

(define-record-type <directory>
  (make-directory previous entries)
  directory?
  (previous directory-previous-version)
  (entries  directory-entries))

(define-record-type <directory-entry>
  (make-directory-entry name kind mtime size perms tuple)
  directory-entry?
  (name   directory-entry-name)
  (kind   directory-entry-kind)
  (mtime  directory-entry-mtime)
  (size   directory-entry-size)
  (perms  directory-entry-permissions)
  (tuple  directory-entry-tuple))

(define (directory->sexp dir)
  "Serialize directory DIR as an s-expression."
  (define (entry->sexp entry)
    (map (lambda (get)
           (get entry))
         (list directory-entry-name directory-entry-kind
               directory-entry-mtime directory-entry-size
               directory-entry-permissions directory-entry-tuple)))

  `(directory
    (version 0)
    (previous ,(directory-previous-version dir))
    (entries ,(map entry->sexp (directory-entries dir)))))

(define (write-directory dir port)
  "Serialize directory DIR to PORT."
  (write (directory->sexp dir) port))

(define (sexp->directory exp)
  "Read EXP, an S-expression, and return the corresponding directory object."
  (define (sexp->entry exp)
    (match exp
      ((name kind mtime size perms tuple)
       (make-directory-entry name kind mtime size perms tuple))))

  (match exp
    (('directory ('version  0)
                 ('previous previous)
                 ('entries  (entries ...)))
     (make-directory previous (map sexp->entry entries)))))

(define (read-directory port)
  "Read a directory from PORT and return it."
  (sexp->directory (read port)))


;;;
;;; Storage pipelines.
;;;

(define-record-type <pipeline>
  (make-pipeline stream-filters chopper indexer block-indexer store-filters)
  pipeline?
  (stream-filters pipeline-stream-filters)
  (chopper        pipeline-chopper)
  (indexer        pipeline-indexer)
  (block-indexer  pipeline-block-indexer)
  (store-filters  pipeline-store-filters))

(define-condition-type &pipeline-error &error
  pipeline-error?
  (pipeline       pipeline-error-pipeline)        ; the pipeline
  (libchop-error  pipeline-error-libchop-error))  ; libchop error code

(define-condition-type &pipeline-storage-error &pipeline-error
  pipeline-storage-error?
  (input pipeline-storage-error-input))           ; input stream or file name

(define-syntax with-pipeline-storage-error-handling
  (syntax-rules ()
    "Convert any libchop error to a SRFI-35 error condition with additional
info, such as the input stream."
    ((_ pl i body ...)
     (catch 'chop-error
       (lambda ()
         body ...)
       (lambda (key err . rest)
         (raise (condition (&pipeline-storage-error
                            (pipeline pl)
                            (libchop-error err)
                            (input i)))))))))

(define* (filtered-stream stream filters #:optional (close-backend? #f))
  "Return a stream that wraps STREAM and is filtered through all of FILTERS.
If CLOSE-BACKEND? is true, then closing the returned stream will close
underlying streams too."
  (let loop ((stream  stream)
             (filters filters))
    (if (null? filters)
        stream
        (let ((f ((car filters))))
          (loop (filtered-stream-open stream f close-backend?)
                (cdr filters))))))

(define (filtered-store store filters)
  "Return a store that wraps STORE and is filtered through all of FILTERS."
  (let loop ((store   store)
             (filters filters))
    (if (null? filters)
        store
        (let-values (((in out) ((car filters))))
          (loop (filtered-block-store-open in out store)
                (cdr filters))))))

(define (dual-filter-class class)
  "Return the ``dual'' of CLASS, a filter class."
  ;; XXX: Quick & dirty hack for lack of a similar feature at the C level.

  (define (dual-direction dir)
    (cond ((string=? dir "unzip") "zip")
          ((string=? dir "zip")   "unzip")
          (else #f)))

  (define rx
    (make-regexp "([a-zA-Z]+)_(unzip|zip)_filter"))

  (and (class-inherits? class (lookup-class "filter"))
       (let* ((name  (class-name class))
              (match (regexp-exec rx name)))
         (and match
              (let ((name      (match:substring match 1))
                    (direction (match:substring match 2)))
                (lookup-class (string-append name "_"
                                             (dual-direction direction)
                                             "_filter")))))))

(define (run-storage-pipeline pipeline file-or-stream store)
  "Pass the contents of FILE-OR-STREAM through PIPELINE, storing the
resulting blocks in STORE and returning its index handle."
  (define stream
    (if (stream? file-or-stream)
        file-or-stream
        (with-pipeline-storage-error-handling pipeline file-or-stream
          (file-stream-open file-or-stream))))

  (define stream*
    (filtered-stream stream (pipeline-stream-filters pipeline)
                     (not (stream? file-or-stream))))

  (define chopper
    ((pipeline-chopper pipeline) stream*))

  (define indexer
    ((pipeline-indexer pipeline)))

  (define block-indexer
    ((pipeline-block-indexer pipeline)))

  (define store*
    ;; XXX: Use the smart block store.
    (filtered-store store (pipeline-store-filters pipeline)))

  (dynamic-wind
    (lambda () #t)
    (lambda ()
      (with-pipeline-storage-error-handling pipeline file-or-stream
        (indexer-index-blocks indexer chopper block-indexer store* store*)))
    (lambda ()
      ;; If we opened STREAM ourselves, then close it.
      (if (not (stream? file-or-stream))
          (stream-close stream)))))

(define (pipeline-index-handle->tuple pipeline index)
  "Return an index tuple for INDEX as produced by PIPELINE.  The tuple
contains information about filters, in addition to INDEX."
  (define zip-class
    (lookup-class "zip_filter_class"))

  (define unzip-class
    (lookup-class "unzip_filter_class"))

  (let ((if (map (lambda (make-filter)
                   (let* ((f (make-filter))
                          (c (object-class f)))
                     (if (object-is-a? c zip-class)
                         (class-name (dual-filter-class c))
                         (error "currently limited to unzip/zip filtered"
                                c))))             ; FIXME
                 (pipeline-stream-filters pipeline)))
        (i  ((pipeline-indexer pipeline)))
        (bi ((pipeline-block-indexer pipeline)))
        (of (map (lambda (make-filters)
                   (let-values (((in out) (make-filters)))
                     (let ((c (object-class out)))
                       (if (object-is-a? c unzip-class)
                           (class-name c)
                           (error "currently limited to zip/unzip filters"
                                  c)))))      ; FIXME
                 (pipeline-store-filters pipeline))))
    (list if (serialize-index-tuple/ascii index i bi) of)))

(define (index-tuple->retriever tuple)
  "Given TUPLE, return a one-argument procedure which, when passed a store,
returns a port from which the contents pointed to by TUPLE can be read."
  (match tuple
    (((stream-filters ...) index (store-filters ...))
     (let-values (((index indexer block-fetcher)
                   (deserialize-index-tuple/ascii index))
                  ((stream-filters)
                   (map (lambda (sf)
                          (lambda ()
                            (make-unzip-filter
                             (lookup-class sf))))
                        stream-filters))
                  ((store-filters)
                   (map (lambda (sf)
                          (lambda ()
                            (let* ((c (lookup-class sf))
                                   (d (dual-filter-class c)))
                              (values (make-zip-filter d)
                                      (make-unzip-filter c)))))
                        store-filters)))
       (lambda (store)
         (let* ((store  (filtered-store store store-filters))
                (stream (indexer-fetch-stream indexer index block-fetcher
                                              store store)))
           (stream->port (filtered-stream stream stream-filters))))))))

(define (index-tuple->verifier tuple)
  "Return a verifier procedure that takes a store and returns a symbol
indicating whether TUPLE is available in that store, missing, corrupt, or
something else."
  (let ((retrieve (index-tuple->retriever tuple)))
    (lambda (store)
      (catch 'chop-error
        (lambda ()
          (let ((port (retrieve store))
                (void (%make-void-port "w")))
            (dump-port port void)
            (close-port port)
            'ok))
        (lambda (key err . _)
          (cond ((eq? err error/store-block-unavailable)
                 'missing)
                ((eq? err error/block-indexer-error)
                 'corrupt)
                (else 'corrupt)))))))


;;;
;;; Actual backup.
;;;

(define %default-storage-pipeline
  (make-pipeline (let ((zip (or (lookup-class "lzo_zip_filter")
                                (lookup-class "zlib_zip_filter"))))
                   `(,(lambda ()
                        ;; Quick input stream compression.
                        (make-zip-filter zip 1))))
                 (lambda (s)
                   (fixed-size-chopper-open s 16384))
                 (lambda ()
                   (tree-indexer-open 256))
                 (lambda ()
                   (chk-block-indexer-open (make-cipher cipher-algorithm/aes256
                                                        cipher-mode/cbc)
                                           hash-method/sha256
                                           hash-method/sha1))
                 '()))

(define %text-storage-pipeline
  ;; Storage pipeline for textual data.
  (make-pipeline '()
                 (lambda (s)
                   (anchor-based-chopper-open s 4096))
                 (lambda ()
                   (tree-indexer-open 256))
                 (lambda ()
                   (chk-block-indexer-open (make-cipher cipher-algorithm/aes256
                                                        cipher-mode/cbc)
                                           hash-method/sha256
                                           hash-method/sha1))

                 ;; No block-level compression since blocks are encrypted.
                 ;; TODO: Use filtered block-indexers to perform block-level
                 ;; compression before encryption.
                 '()))

(define %directory-storage-pipeline
  ;; The pipeline suitable for directories in this s-exp format.
  %text-storage-pipeline)

(define %compressed-data-storage-pipeline
  ;; Storage pipeline for compressed data (MP3, JPG, etc.)
  (make-pipeline '()
                 (lambda (s)
                   (fixed-size-chopper-open s 16384))
                 (lambda ()
                   (tree-indexer-open 512))
                 (lambda ()
                   ;; Use a more lightweight encryption scheme for speed, and
                   ;; because the plaintext is essentially random already.
                   (chk-block-indexer-open (make-cipher cipher-algorithm/blowfish
                                                        cipher-mode/cbc)
                                           hash-method/md5
                                           hash-method/sha1))
                 '()))


(define (file-extension file)
  "Return the extension of file name FILE or #f if it has none."
  (let ((dot (string-rindex file #\.)))
    (and dot
         (substring file (+ 1 dot) (string-length file)))))

(define (indexed-block-exists? index store)
  "Return #t if the block pointed to by INDEX exists in STORE"
  (let-values (((index indexer fetcher)
                (deserialize-index-tuple/ascii index)))
    (block-fetcher-exists? fetcher index store)))

(define (most-suitable-pipeline file stat)
  "Return the most suitable pipeline to store FILE."
  (define %text-extensions
    '("txt" "org" "c" "h" "cc" "hh" "cpp" "hpp" "C" "scm" "ss" "sls"
      "lisp" "el" "scala" "java" "m" "v" "hs" "py" "pl"
      "am" "in" "ac" "m4" "nix" "xml" "svg"
      "texi" "texinfo" "tex" "ltx" "sty" "lout" "skb"))

  (define %compressed-extensions
    '("mp3" "mp4" "mpc" "mpg" "wma" "ogg" "ogv" "avi" "mov"
      "jpg" "png" "odt" "pack"
      "gz" "bzip2" "bz2" "xz" "lz" "zip" "tgz" "tbz2" "arj" "rar"))

  (let ((ext (and=> (file-extension file) string-downcase)))
    (cond ((member ext %text-extensions)
           %text-storage-pipeline)
          ((member ext %compressed-extensions)
           %compressed-data-storage-pipeline)
          (else
           %default-storage-pipeline))))

(define worthless-file?
  (let ((rx   (make-regexp "(\\.(o|lo|la|a|so|gcda|gcno|gcda\\.info|tmp|swp)|~)$"))
        (dirs '(".libs" ".deps" "autom4te.cache" "CVS" ".svn")))
    (lambda (file-name stat)
      "Return true if FILE-NAME and STAT designate a worthless file or
directory."
      (case (stat:type stat)
        ((directory)
         (member (basename file-name) dirs))
        (else
         (regexp-exec rx file-name))))))


(define (store-directory dir store)
  "Serialize DIR, write it to STORE, and return its index tuple."
  (let* ((str   (call-with-output-string (cut write-directory dir <>)))
         (index (run-storage-pipeline %directory-storage-pipeline
                                      (mem-stream-open (string->utf8 str))
                                      store)))
    (pipeline-index-handle->tuple %directory-storage-pipeline index)))

(define (run-storage-pipeline/recursive choose-pipeline dir store)
  "Store directory DIR into STORE using the storage pipeline returned by
CHOOSE-PIPELINE, and return its index handle."

  ;; TODO: make WORTHLESS-FILE? a parameter.

  (define (stat->cached-entry stat)
    ;; Return an mtime/tuple pair corresponding to STAT or #f.
    (let* ((ino   (stat:ino stat))
           (dev   (stat:dev stat))
           (entry (false-if-exception
                   (store-read-block %file-index-mapping
                                     (string->utf8
                                      (format #f "(~a . ~a)" ino dev))))))
      (and entry
           (call-with-input-string (utf8->string entry) read))))

  (define (stat->index-tuple stat)
    ;; Return the serialized index tuple corresponding to STAT or #f.
    (match (stat->cached-entry stat)
      (((? integer? mtime) . index-tuple)
       (and (= mtime (stat:mtime stat))
            index-tuple))
      (_ #f)))

  (define* (cache-index stat index #:optional stamp)
    (let* ((ino    (stat:ino stat))
           (dev    (stat:dev stat))
           (stamp  (or stamp (stat:mtime stat)))
           (key    (format #f "(~a . ~a)" ino dev)))
      (store-write-block %file-index-mapping
                         (string->utf8 key)
                         (string->utf8
                          (format #f "(~s . ~s)" stamp index)))))

  (define (store/cache stat file)
    (define input
      (case (stat:type stat)
        ((symlink)
         (mem-stream-open (string->utf8 (readlink file))))
        ((regular) file)
        (else
         (warn (_ "file `~a' of type `~a' will not be saved")
               file (stat:type stat))
         #f)))

    (and input
         (let* ((pipeline (choose-pipeline file stat))
                (index    (run-storage-pipeline pipeline input store))
                (index*   (pipeline-index-handle->tuple pipeline index)))
           (cache-index stat index*)
           index*)))

  (define (store-directory* stat entries)
    ;; Like `store-directory', and update %FILE-INDEX-MAPPING with a mapping
    ;; from STAT to the index tuple of ENTRIES.
    (define (do-store prev-tuple)
      (let* ((dir   (make-directory prev-tuple entries))
             (index (store-directory dir store)))
        ;; Since mtime can't be used to determine whether DIR changed, store
        ;; its list of entries in the file/index mapping.
        (cache-index stat index (directory->sexp dir))
        index))

    (let ((prev-entry (stat->cached-entry stat)))
      (if (pair? prev-entry)
          (let* ((prev-tuple   (cdr prev-entry))
                 (prev-dir     (sexp->directory (car prev-entry)))
                 (prev-entries (directory-entries prev-dir)))
            (if (lset= equal? prev-entries entries)
                (match prev-tuple                 ; directory unchanged
                  ((_ index _)
                   (if (tip-exists? index)
                       prev-tuple
                       (let ((index (store-directory prev-dir store)))
                         (if (equal? index prev-tuple)
                             index
                             (raise (condition    ; XXX: not very appropriate
                                     (&pipeline-storage-error
                                      (pipeline %directory-storage-pipeline)
                                      (libchop-error 0)
                                      (input prev-dir)))))))))
                (do-store prev-tuple)))           ; directory changed
          (do-store #f))))

  (define (tip-exists? index)
    ;; Return #t if the root block pointed to by INDEX exists.
    (indexed-block-exists? index store))

  (define (enter-directory? dir-name stat result)
    ;; Return #t when we want to enter directory DIR-NAME.  Note that we
    ;; enter DIR-NAME even if its mtime didn't change because a directory's
    ;; mtime is typically updated only when files are added or removed, not
    ;; when they are modified.
    (not (worthless-file? dir-name stat)))

  (define (process-file file stat result)
    ;; Return RESULT augmented with FILE's meta-data, taken from STAT, and
    ;; its index tuple in STORE.  As a side-effect, store FILE to STORE if it
    ;; isn't there already.
    (if (worthless-file? file stat)
        result
        (let ((index
               (if (= (stat:size stat) 0)
                   #f
                   (or (match (stat->index-tuple stat)
                         (((stream-filters ...) index (store-filters ...))
                          (and (tip-exists? index)
                               (list stream-filters index store-filters)))
                         (_ #f))
                       (store/cache stat file)))))
          (match result
            (((entries ...) result ...)
             (cons (cons (make-directory-entry (basename file)
                                               (stat:type stat)
                                               (stat:mtime stat)
                                               (stat:size stat)
                                               (stat:perms stat)
                                               index)
                         entries)
                   result))))))

  (define (enter-directory dir stat result)
    ;; Add to RESULT an empty list that will hold DIR's contents.
    (cons '() result))

  (define (leave-directory dir stat result)
    ;; Collect from the head of RESULT the file/index returned by
    ;; `process-file' for each file under DIR, and replace them with DIR's
    ;; meta-data/index-tuple.  As a side-effect, store DIR's contents to
    ;; STORE.
    (match result
      (((entries ...) (siblings ...) result ...)
       (cons (cons (make-directory-entry (basename dir)
                                         (stat:type stat)
                                         (stat:mtime stat)
                                         (stat:size stat)
                                         (stat:perms stat)
                                         (store-directory* stat entries))
                   siblings)
             result))))

  (define (skip-directory dir stat result)
    ;; Skip DIR, because it was considered worthless.
    result)

  (define (report-error dir stat errno result)
    ;; DIR is unreadable, so ignore it.
    ;; TODO: Add an option to error out?
    (format (current-error-port) (_ "~a ignored: ~a~%")
            dir (strerror errno))
    result)

  (let ((result
         (file-system-fold enter-directory?
                           process-file
                           enter-directory
                           leave-directory
                           skip-directory
                           report-error
                           '(())
                           dir)))
    (match result
      ((((? directory-entry? dir)))
       (directory-entry-tuple dir)))))


;;;
;;; Retrieval.
;;;

(define* (list-directory-contents store tuple port
                                  #:key (verbose? #f) (recursive? #t)
                                        (history? #f))
  "Write to PORT, in a human-readable way, the contents of the directory at
TUPLE in STORE."
  ;; FIXME: Reuse `file-system-fold'.

  (define (nest indent)
    (string-append indent "    "))

  (define (->date epoch)
    (let* ((now  (current-time time-monotonic))
           (then (make-time time-monotonic 0 epoch))
           (date (time-monotonic->date then)))
      (date->string date
                    (if (>= (time-second (time-difference now then))
                            (* 3600 30 6))
                        "~b ~e  ~Y"
                        "~b ~e ~H:~M"))))

  (define (->perms perms)
    (define (one perms)
      (string-append (if (bit-set? 2 perms) "r" "-")
                     (if (bit-set? 1 perms) "w" "-")
                     (if (bit-set? 0 perms) "x" "-")))
    (string-append (one (arithmetic-shift perms -6))
                   (one (logand 7 (arithmetic-shift perms -3)))
                   (one (logand 7 perms))))

  (define (display-entry entry indent)
    (format port "~a~a~a ~8,d ~16,a ~a~:[~*~; ~s~]~%"
            indent
            (case (directory-entry-kind entry)
              ((regular) "-")
              ((directory) "d")
              ((symlink) "l")
              ((block-special) "b")
              ((char-special) "c")
              ((fifo) "f")
              ((socket) "s")
              (else "?"))
            (->perms (directory-entry-permissions entry))
            (directory-entry-size entry)
            (->date (directory-entry-mtime entry))
            (directory-entry-name entry)
            verbose? (directory-entry-tuple entry)))

  (define (tuple->directory tuple)
    ;; Fetch the directory at TUPLE and return it.
    (let ((retrieve (index-tuple->retriever tuple)))
      (read-directory (retrieve store))))

  (define (make-previous-version-entry prev)
    (make-directory-entry "//previous-version//"
                          'directory
                          0 0 0
                          prev))

  (let loop ((tuple   tuple)
             (indent  "")
             (visited vlist-null))                ; tuples of visited dirs
    (define (visited? tuple)
      (vhash-assoc tuple visited))

    ;; Avoid visiting the same directory several times---useful when
    ;; RECURSIVE? and HISTORY? are both true.
    (or (and (visited? tuple) visited)
        (let* ((dir  (tuple->directory tuple))
               (prev (directory-previous-version dir)))
          (if (and (not history?) prev)
              (display-entry (make-previous-version-entry prev) indent))

          (let ((visited
                 (let liip ((entries (directory-entries dir))
                            (visited visited))
                   (or (and (null? entries) visited)
                       (let ((e (car entries)))
                         (display-entry e indent)
                         (liip (cdr entries)
                               (if (and (eq? 'directory
                                             (directory-entry-kind e))
                                        recursive?)
                                   (loop (directory-entry-tuple e)
                                         (nest indent)
                                         (vhash-cons tuple #t visited))
                                   visited)))))))

            (if (and history? prev)
                (begin
                  (display-entry (make-previous-version-entry prev) indent)
                  (loop prev (nest indent)
                        (vhash-cons tuple #t visited)))
                visited))))))

(define (dump-port in out)
  "Read as much data as possible from IN and write it to OUT."
  (define buffer-size 4096)
  (define buffer
    (make-bytevector buffer-size))

  (let loop ((bytes (get-bytevector-n! in buffer 0 buffer-size)))
    (or (eof-object? bytes)
        (begin
          (put-bytevector out buffer 0 bytes)
          (loop (get-bytevector-n! in buffer 0 buffer-size))))))

(define (verify-tree store tuple)
  "Read the directory pointed to by TUPLE from STORE and check the
availability and integrity of each file and directory contained in that
directory, recursively.  Return #t on success, #f otherwise."
  (define (display-status s)
    (format #t "~a~%"
            (case s
              ((ok) (_ "OK"))
              ((corrupt) (_ "CORRUPT"))
              ((missing) (_ "MISSING"))
              (else s)))
    (eq? s 'ok))

  (let loop ((tuple tuple)
             (file  "")
             (result #t))
    (let* ((retrieve (index-tuple->retriever tuple))
           (verify   (index-tuple->verifier tuple))
           (status   (verify store)))
      ;; XXX: We're retrieving & decoding TUPLE twice here.
      (format #t "~a\t~s\t"
              (match file
                ("" "/")
                (_  file))
              tuple)
      (display-status status)

      (and (eq? status 'ok)
           (let liip ((entries (directory-entries
                                (read-directory (retrieve store))))
                      (status  status))
             (or (null? entries)
                 (let* ((e     (car entries))
                        (name  (directory-entry-name e))
                        (tuple (directory-entry-tuple e))
                        (file  (string-append file "/" name))
                        (status
                         (case (directory-entry-kind e)
                           ((directory)
                            (loop tuple file status))
                           (else
                            (format #t "~a\t~s\t" file tuple)
                            (if tuple             ; #f means "empty file"
                                (let ((verify (index-tuple->verifier tuple)))
                                  (display-status (verify store)))
                                (display-status 'ok))))))

                   (liip (cdr entries) status))))))))


(define (restore-tree store tuple dir)
  "Read the directory pointed to by TUPLE from STORE and restore it under
directory DIR."
  (mkdir dir)
  (let loop ((tuple tuple)
             (dir   dir))
    (let ((retrieve (index-tuple->retriever tuple)))
      (let liip ((entries (directory-entries
                           (read-directory (retrieve store)))))
        (or (null? entries)
            (eof-object? entries)
            (let* ((e     (car entries))
                   (name  (directory-entry-name e))
                   (perms (directory-entry-permissions e))
                   (tuple (directory-entry-tuple e))
                   (file  (string-append dir "/" name)))
              (case (directory-entry-kind e)
                ((directory)
                 (let ((subdir file))
                   (mkdir subdir)
                   (chmod subdir #o700)           ; so we can write to it
                   (loop tuple subdir)
                   (chmod subdir perms)
                   #t))
                ((regular)
                 (let ((out (open-output-file file)))
                   (if tuple                      ; #f means "empty file"
                       (let ((get (index-tuple->retriever tuple)))
                         (dump-port (get store) out)
                         (close out)
                         (chmod file perms)))
                   (close out)
                   (chmod file perms)
                   #t))
                ((symlink)
                 (let ((get (index-tuple->retriever tuple)))
                   (symlink (call-with-output-string
                             (cute dump-port (get store) <>))
                            file)
                   #t))
                (else
                 (warn (_ "file `~a' of type `~a' not restored")
                       file (directory-entry-kind e))
                 #t))
              (liip (cdr entries))))))))


;;;
;;; Command-line entry point.
;;;

(define (show-help)
  (display (_ "chop-backup [OPTION] STORE ARGS ...\n"))
  (display (_ "Create or access an encrypted file system snapshot.\n"))
  (display (_ "
  -b, --backup           Create an encrypted backup of the given directories,
                         store it in file STORE, and return a tuple that
                         designates the backup (default action)."))
  (display (_ "
  -R, --recent           List recent backups and their tuple."))
  (display (_ "
  -p, --probe            List recent backups and their tuple that are
                         available in the given store."))
  (newline)
  (display (_ "
  -l, --list[=OPTS]      List the contents of the directory pointed to by the
                         tuple specified in ARGS and stored at STORE.  OPTS
                         is a comma-separated list of long or one-letter
                         options: `r' or `recursive',`f' or `flat',
                         `h' or `history', `l' or `latest',
                         `v' or `verbose', `c' or `concise'."))
  (display (_ "
  -s, --show             Retrieve from STORE and show the contents pointed to
                         by the given tuple."))
  (display (_ "
  -c, --check            Check whether the contents of the directory pointed
                         to by the given tuple are available from STORE,
                         recursively."))
  (display (_ "
  -r, --restore          Retrieve from STORE and restore the complete file
                         system hierarchy pointed to by the given tuple, and
                         write it to the given directory."))
  (newline)
  (display (_"
  -h, --help             Give this help list."))
  (display (_ "
  -V, --version          Print program version."))
  (newline)
  (newline)
  (format #t (_ "Report bugs to ~a.~%") (libchop-bug-address)))

(define (show-version)
  (format #t "chop-backup (libchop) ~a\n" (libchop-version)))

(define (leave fmt . args)
  (apply format (current-error-port) (string-append fmt "~%") args)
  (exit 1))

(define (write* obj)
  (write obj)
  (newline)
  obj)

(define %options
  (list (option '(#\h "help") #f #f
                (lambda args
                  (show-help)
                  (exit 0)))
        (option '(#\V "version") #f #f
                (lambda args
                  (show-version)
                  (exit 0)))

        (option '(#\b "backup") #f #f
                (lambda (opt name arg result)
                  (alist-cons 'action 'backup
                              (alist-delete 'action result eq?))))
        (option '(#\l "list") #f #t
                (lambda (opt name arg result)
                  (define canonical-options
                    (fold (lambda (opt result)
                            (case opt
                              ((r recursive)
                               (cons 'recursive result))
                              ((f flat)
                               (delq 'recursive result))
                              ((h history)
                               (cons 'history result))
                              ((l latest)
                               (delq 'history result))
                              ((v verbose)
                               (cons 'verbose result))
                              ((c concise)
                               (delq 'verbose result))
                              (else result)))
                          '()
                          (if arg
                              (map string->symbol
                                   (string-split arg #\,))
                              '())))

                  (alist-cons 'list-options canonical-options
                              (alist-cons 'action 'list result))))
        (option '(#\s "show") #f #f
                (lambda (opt name arg result)
                  (alist-cons 'action 'show
                              (alist-delete 'action result eq?))))
        (option '(#\c "check") #f #f
                (lambda (opt name arg result)
                  (alist-cons 'action 'verify
                              (alist-delete 'action result eq?))))
        (option '(#\r "restore") #f #f
                (lambda (opt name arg result)
                  (alist-cons 'action 'restore
                              (alist-delete 'action result eq?))))
        (option '(#\R "recent") #f #f
                (lambda (opt name arg result)
                  (alist-cons 'action 'list-recent
                              (alist-delete 'action result eq?))))
        (option '(#\p "probe") #f #f
                (lambda (opt name arg result)
                  (alist-cons 'action 'probe
                              (alist-delete 'action result eq?))))))

(define %default-options
  '((arguments . ())))

(define (chop-backup . args)
  "Backup FILE and EXTRA-FILES, recursively, to STORE-FILE.  Return an index
tuple that can be used to restore the whole directory hierarchy."
  (define (parse-args args)
    (args-fold args %options
               (lambda (opt name arg result)
                 (leave (_ "~A: unrecognized option") name))
               (lambda (arg result)
                 (alist-cons 'arguments
                             (cons arg
                                   (assq-ref result 'arguments))
                             (alist-delete 'arguments result
                                           eq?)))
               %default-options))

  (define (open-store file)
    (file-based-block-store-open (lookup-class "fs_block_store")
                                 file
                                 (logior O_CREAT O_RDWR) #o644))

  (define (backup store-file files)
    (catch 'chop-error
      (lambda ()
        (let ((store (open-store store-file)))
          (match files
            ((file)
             (guard (c ((pipeline-storage-error? c)
                        (leave (_ "error: while creating backup of `~a': ~a~%")
                               (pipeline-storage-error-input c)
                               (error-message (pipeline-error-libchop-error c)))))
               (let* ((file  (canonicalize-path file))
                      (tuple (run-storage-pipeline/recursive
                              most-suitable-pipeline file store)))
                 (save-backup-tuple file tuple)
                 (write* tuple))))
            ((files ...)
             (let* ((files  (map canonicalize-path files))
                    (stats  (map lstat files))
                    (tuples (map (cut run-storage-pipeline/recursive
                                      most-suitable-pipeline <> store)
                                 files))
                    (entries (map (match-lambda
                                   ((file stat tuple)
                                    (make-directory-entry (basename file)
                                                          (stat:type stat)
                                                          (stat:mtime stat)
                                                          (stat:size stat)
                                                          (stat:perms stat)
                                                          tuple)))
                                  (zip files stats tuples)))

                    ;; Aggregate all of FILES as if it were a single directory.
                    (tuple  (store-directory (make-directory #f entries)
                                             store)))
               (map save-backup-tuple files tuples)
               (write* tuple))))))
      (lambda (key err . rest)
        (leave (_ "error: ~a") (error-message err)))))

  (define (show store tuple)
    (let* ((retrieve (index-tuple->retriever tuple))
           (port     (retrieve store)))
      (dump-port port (current-output-port))
      (store-close store)))

  (false-if-exception (setlocale LC_ALL ""))
  (textdomain "libchop")

  (let* ((options (parse-args args))
         (action  (or (assq-ref options 'action) 'backup))
         (args    (reverse (assq-ref options 'arguments))))

    (case action
      ((backup)
       (match args
         ((store-file files ...)
          (backup store-file files))
         (_
          (leave (_ "too few arguments for `backup' operation")))))

      ((list)
       (let ((opts (or (assq-ref options 'list-options) '())))
         (match args
           ((store-file tuple)
            (list-directory-contents (open-store store-file)
                                     (with-input-from-string tuple read)
                                     (current-output-port)
                                     #:verbose? (memq 'verbose opts)
                                     #:recursive? (memq 'recursive opts)
                                     #:history? (memq 'history opts)))
           ((store-file)
            (let ((store (open-store store-file)))
              (match (most-recent-backup-tuple store)
                (((? string? name) . tuple)
                 (warn (_ "accessing most recent backup of `~a' at `~s'")
                       name tuple)
                 (list-directory-contents store tuple
                                          (current-output-port)
                                          #:verbose? (memq 'verbose opts)
                                          #:recursive? (memq 'recursive opts)
                                          #:history? (memq 'history opts)))
                (_
                 (leave (_ "please specify the tuple of a directory"))))))
           (_
            (leave (_ "wrong number of arguments for the `list' operation"))))))

      ((show)
       (match args
         ((store-file tuple)
          (show (open-store store-file)
                (with-input-from-string tuple read)))
         ((store-file)
          (let ((store (open-store store-file)))
            (match (most-recent-backup-tuple store)
              (((? string? name) . tuple)
               (warn (_ "accessing most recent backup of `~a' at `~s'")
                     name tuple)
               (show store tuple))
              (_
               (leave (_ "please specify the tuple of a directory"))))))
         (_
          (leave (_ "wrong number of arguments for the `show' operation")))))

      ((verify)
       (match args
         ((store-file tuple)
          (let ((store (open-store store-file))
                (tuple (with-input-from-string tuple read)))
            (exit (verify-tree store tuple))))
         ((store-file)
          (let ((store (open-store store-file)))
            (match (most-recent-backup-tuple store)
              (((? string? name) . tuple)
               (warn (_ "verifying most recent backup of `~a' at `~s'")
                     name tuple)
               (exit (verify-tree store tuple)))
              (_
               (leave (_ "please specify the tuple of a directory"))))))
         (_
          (leave (_ "wrong number of arguments for the `verify' operation")))))

      ((restore)
       (match args
         ((store-file tuple out-dir)
          (let ((store (open-store store-file))
                (tuple (with-input-from-string tuple read)))
            (restore-tree store tuple out-dir)))
         ((store-file out-dir)
          (let ((store (open-store store-file)))
            (match (most-recent-backup-tuple store)
              (((? string? name) . tuple)
               (warn (_ "restoring most recent backup of `~a' at `~s'")
                     name tuple)
               (restore-tree store tuple out-dir))
              (_
               (leave (_ "please specify the tuple of a directory"))))))
         (_
          (leave (_ "wrong number of arguments for the `restore' operation")))))

      ((list-recent)
       (for-each (match-lambda
                  ((dir tuples ...)
                   (format #t "~:{~a\t~s~%~}"
                           (map (cut list dir <>) tuples))))
                 (recent-backups)))

      ((probe)
       (match args
         ((store-file)
          (let ((store (open-store store-file)))
            (for-each (match-lambda
                       ((dir tuples ...)
                        (for-each (lambda (tuple)
                                    (format #t "~a\t~s~%" dir tuple))
                                  (filter (compose
                                           (cut indexed-block-exists? <> store)
                                           (match-lambda ((_ index _) index)))
                                          tuples))))
                      (recent-backups))))
         (_
          (leave (_ "wrong number of arguments for the `probe' operation")))))

      (else (error "what's this?" action)))))

;; Local Variables:
;; eval: (put 'guard 'scheme-indent-function 1)
;; eval: (put 'with-pipeline-storage-error-handling 'scheme-indent-function 2)
;; End:
