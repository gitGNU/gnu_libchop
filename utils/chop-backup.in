#!/bin/sh
# aside from this initial boilerplate, this is actually -*- scheme -*- code
main="(module-ref (resolve-module '(chop-backup)) 'main)"
prefix="@prefix@"
exec ${GUILE:-@GUILE@} -L "@guilemoduledir@" \
  -l "$0" -c "(apply $main (cdr (command-line)))" "$@"
!#
;;; Copyright (C) 2011  Ludovic Court√®s <ludo@gnu.org>
;;;
;;; Libchop is free software: you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation, either version 3 of the License, or
;;; (at your option) any later version.
;;;
;;; Libchop is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with libchop.  If not, see <http://www.gnu.org/licenses/>.

(define-module (chop-backup)
  #:use-module (chop)
  #:use-module (srfi srfi-1)
  #:use-module (srfi srfi-9)
  #:use-module (srfi srfi-11)
  #:use-module (srfi srfi-19)
  #:use-module (srfi srfi-26)
  #:use-module (srfi srfi-37)
  #:use-module (srfi srfi-60)
  #:use-module (rnrs bytevectors)
  #:use-module ((rnrs io ports) #:select (get-bytevector-n! put-bytevector))
  #:use-module (ice-9 match)
  #:use-module (ice-9 vlist)
  #:use-module (ice-9 regex)
  #:export (main))

;;; Commentary:
;;;
;;; This modules provides tools to store (encrypted) backups of whole file
;;; hierarchies.
;;;
;;; Code:


;;;
;;; User interface.
;;;

(define-syntax warn
  (syntax-rules ()
    ((_ message args ...)
     (begin
      (format (current-error-port) message args ...)
      (newline (current-error-port))))))

(if (not (string=? "@PACKAGE_VERSION@" (libchop-version)))
    (warn "I was written for libchop @PACKAGE_VERSION@ but I'm using ~a!"
          (libchop-version)))


;;;
;;; Functional file system traversal.
;;;

(define (file-system-fold enter? leaf down up skip init file-name)
  "Traverse the directory at FILE-NAME, recursively.  Enter sub-directories
only when (ENTER? PATH STAT RESULT) returns true.  When a sub-directory is
entered, call (DOWN PATH STAT RESULT), where PATH is the path of the
sub-directory and STAT the result of (lstat PATH); when it is left, call (UP
PATH STAT RESULT).  For each file in a directory, call (LEAF PATH STAT
RESULT).  Return the result of these successive applications.  When ENTER?
returns no, call (SKIP PATH STAT RESULT)."

  (define (mark v s)
    (vhash-cons (cons (stat:dev s) (stat:ino s)) #t v))

  (define (visited? v s)
    (vhash-assoc (cons (stat:dev s) (stat:ino s)) v))

  (let loop ((name    file-name)
             (path    "")
             (result  init)
             (visited vlist-null))

    (define full-name
      (if (string=? path "")
          name
          (string-append path "/" name)))

    (define dir-stat
      (lstat full-name))

    (if (visited? visited dir-stat)
        (values result visited)
        (if (enter? full-name dir-stat result)
            (let ((dir     (opendir full-name))
                  (visited (mark visited dir-stat)))
              (let liip ((entry   (readdir dir))
                         (result  (down full-name dir-stat result))
                         (subdirs '()))
                (cond ((eof-object? entry)
                       (begin
                         (closedir dir)
                         (let ((r+v
                                (fold (lambda (subdir result+visited)
                                        (call-with-values
                                            (lambda ()
                                              (loop subdir
                                                    full-name
                                                    (car result+visited)
                                                    (cdr result+visited)))
                                          cons))
                                      (cons result visited)
                                      subdirs)))
                           (values (up full-name dir-stat (car r+v))
                                   (cdr r+v)))))
                      ((or (string=? entry ".")
                           (string=? entry ".."))
                       (liip (readdir dir)
                             result
                             subdirs))
                      (else
                       (let ((stat
                              (lstat (string-append full-name "/" entry))))
                         (cond
                          ((eq? (stat:type stat) 'directory)
                           (liip (readdir dir)
                                 result
                                 (cons entry subdirs)))
                          (else
                           (liip (readdir dir)
                                 (leaf (string-append full-name "/" entry)
                                       stat
                                       result)
                                 subdirs))))))))
            (values (skip full-name dir-stat result)
                    (mark visited dir-stat))))))


;;;
;;; Persistent backup state.
;;;

(define (cache-directory)
  (or (getenv "XDG_CACHE_HOME")
      (string-append (getenv "HOME") "/.cache/chop/backup")))

(define (mkdir-p dir)
  "Create directory DIR and all its ancestors."
  (define absolute?
    (string-prefix? "/" dir))

  (define not-slash
    (char-set-complement (char-set #\/)))

  (let loop ((components (string-tokenize dir not-slash))
             (root       (if absolute?
                             ""
                             ".")))
    (or (null? components)
        (let ((path (string-append root "/" (car components))))
          (catch 'system-error
            (lambda ()
              (mkdir path)
              (loop (cdr components) path))
            (lambda args
              (if (= EEXIST (system-error-errno args))
                  (loop (cdr components) path)
                  (apply throw args))))))))

(or (file-exists? (cache-directory))
    (mkdir-p (cache-directory)))

(define (cache-file name)
  (string-append (cache-directory) "/" name))

(define %file-index-mapping
  ;; Map (INODE . DEVICE) to (MTIME . INDEX-TUPLE).
  (file-based-block-store-open (lookup-class "fs_block_store")
                               (cache-file "file-index-mapping")
                               (logior O_CREAT O_RDWR)
                               #o600))

(define %recent-backups-file
  ;; A cache containing a list of file/tuple pairs.
  (cache-file "recent-backups"))

(define (save-backup-tuple dir tuple)
  "Append the DIR/TUPLE pair to the recent-backups cache file."
  (let ((backups (if (file-exists? %recent-backups-file)
                     (call-with-input-file %recent-backups-file read)
                     '())))
    (call-with-output-file %recent-backups-file
      (lambda (p)
        (write (alist-cons dir tuple (alist-delete dir backups))
               p)))))

(define (most-recent-backup-tuple)
  "Return the file/tuple pair corresponding to the most recent backup."
  (and (file-exists? %recent-backups-file)
       (car (call-with-input-file %recent-backups-file read))))


;;;
;;; Directory meta-data.
;;;

;; We want to (1) allow efficient processing of directory data, and (2)
;; decouple the serialized format of directories from the in-memory
;; representation.  Thus, we use record types for the in-memory
;; representations, and s-exps only for the external representation.

(define-record-type <directory>
  (make-directory previous entries)
  directory?
  (previous directory-previous-version)
  (entries  directory-entries))

(define-record-type <directory-entry>
  (make-directory-entry name kind mtime size perms tuple)
  directory-entry?
  (name   directory-entry-name)
  (kind   directory-entry-kind)
  (mtime  directory-entry-mtime)
  (size   directory-entry-size)
  (perms  directory-entry-permissions)
  (tuple  directory-entry-tuple))

(define (directory->sexp dir)
  "Serialize directory DIR as an s-expression."
  (define (entry->sexp entry)
    (map (lambda (get)
           (get entry))
         (list directory-entry-name directory-entry-kind
               directory-entry-mtime directory-entry-size
               directory-entry-permissions directory-entry-tuple)))

  `(directory
    (version 0)
    (previous ,(directory-previous-version dir))
    (entries ,(map entry->sexp (directory-entries dir)))))

(define (write-directory dir port)
  "Serialize directory DIR to PORT."
  (write (directory->sexp dir) port))

(define (sexp->directory exp)
  "Read EXP, an S-expression, and return the corresponding directory object."
  (define (sexp->entry exp)
    (match exp
      ((name kind mtime size perms tuple)
       (make-directory-entry name kind mtime size perms tuple))))

  (match exp
    (('directory ('version  0)
                 ('previous previous)
                 ('entries  (entries ...)))
     (make-directory previous (map sexp->entry entries)))))

(define (read-directory port)
  "Read a directory from PORT and return it."
  (sexp->directory (read port)))


;;;
;;; Storage pipelines.
;;;

(define-record-type <pipeline>
  (make-pipeline stream-filters chopper indexer block-indexer store-filters)
  pipeline?
  (stream-filters pipeline-stream-filters)
  (chopper        pipeline-chopper)
  (indexer        pipeline-indexer)
  (block-indexer  pipeline-block-indexer)
  (store-filters  pipeline-store-filters))

(define (filtered-stream stream filters)
  "Return a stream that wraps STREAM and is filtered through all of FILTERS."
  (let loop ((stream  stream)
             (filters filters))
    (if (null? filters)
        stream
        (let ((f ((car filters))))
          (loop (filtered-stream-open stream f)
                (cdr filters))))))

(define (filtered-store store filters)
  "Return a store that wraps STORE and is filtered through all of FILTERS."
  (let loop ((store   store)
             (filters filters))
    (if (null? filters)
        store
        (let-values (((in out) ((car filters))))
          (loop (filtered-block-store-open in out store)
                (cdr filters))))))

(define (dual-filter-class class)
  "Return the ``dual'' of CLASS, a filter class."
  ;; XXX: Quick & dirty hack for lack of a similar feature at the C level.

  (define (dual-direction dir)
    (cond ((string=? dir "unzip") "zip")
          ((string=? dir "zip")   "unzip")
          (else #f)))

  (define rx
    (make-regexp "([a-zA-Z]+)_(unzip|zip)_filter"))

  (and (class-inherits? class (lookup-class "filter"))
       (let* ((name  (class-name class))
              (match (regexp-exec rx name)))
         (and match
              (let ((name      (match:substring match 1))
                    (direction (match:substring match 2)))
                (lookup-class (string-append name "_"
                                             (dual-direction direction)
                                             "_filter")))))))

(define (run-storage-pipeline pipeline file-or-stream store)
  "Pass the contents of FILE-OR-STREAM through PIPELINE, storing the
resulting blocks in STORE and returning its index handle."
  (define stream
    (if (stream? file-or-stream)
        file-or-stream
        (file-stream-open file-or-stream)))

  (define stream*
    (filtered-stream stream (pipeline-stream-filters pipeline)))

  (define chopper
    ((pipeline-chopper pipeline) stream*))

  (define indexer
    ((pipeline-indexer pipeline)))

  (define block-indexer
    ((pipeline-block-indexer pipeline)))

  (define store*
    ;; XXX: Use the smart block store.
    (filtered-store store (pipeline-store-filters pipeline)))

  (indexer-index-blocks indexer chopper block-indexer store* store*))

(define (pipeline-index-handle->tuple pipeline index)
  "Return an index tuple for INDEX as produced by PIPELINE.  The tuple
contains information about filters, in addition to INDEX."
  (define unzip-class
    (lookup-class "unzip_filter_class"))

  (let ((if (map (lambda (make-filter)
                   (serialize-object/ascii (make-filter)))
                 (pipeline-stream-filters pipeline)))
        (i  ((pipeline-indexer pipeline)))
        (bi ((pipeline-block-indexer pipeline)))
        (of (map (lambda (make-filters)
                   (let-values (((in out) (make-filters)))
                     (let ((c (object-class out)))
                       (if (object-is-a? c unzip-class)
                           (class-name c)
                           (error "currently limited to zip/unzip filters"
                                  c)))))      ; FIXME
                 (pipeline-store-filters pipeline))))
    (list if (serialize-index-tuple/ascii index i bi) of)))

(define (index-tuple->retriever tuple)
  "Given TUPLE, return a one-argument procedure which, when passed a store,
returns a port from which the contents pointed to by TUPLE can be read."
  (match tuple
    (((stream-filters ...) index (store-filters ...))
     (let-values (((index indexer block-fetcher)
                   (deserialize-index-tuple/ascii index))
                  ((stream-filters)
                   (map (lambda (sf)
                          (lambda ()
                            (make-unzip-filter
                             (lookup-class sf))))
                        stream-filters))
                  ((store-filters)
                   (map (lambda (sf)
                          (lambda ()
                            (let* ((c (lookup-class sf))
                                   (d (dual-filter-class c)))
                              (values (make-zip-filter d)
                                      (make-unzip-filter c)))))
                        store-filters)))
       (lambda (store)
         (let* ((store  (filtered-store store store-filters))
                (stream (indexer-fetch-stream indexer index block-fetcher
                                              store store)))
           (stream->port (filtered-stream stream stream-filters))))))))


;;;
;;; Actual backup.
;;;

(define %default-storage-pipeline
  (make-pipeline '()
                 (lambda (s)
                   (fixed-size-chopper-open s 8192))
                 (lambda ()
                   (tree-indexer-open 256))
                 (lambda ()
                   (chk-block-indexer-open (make-cipher cipher-algorithm/aes256
                                                        cipher-mode/cbc)
                                           hash-method/sha256
                                           hash-method/md5))
                 '()))

(define %text-storage-pipeline
  ;; Storage pipeline for textual data.
  (make-pipeline '()
                 (lambda (s)
                   (anchor-based-chopper-open s 4096))
                 (lambda ()
                   (tree-indexer-open 256))
                 (lambda ()
                   (chk-block-indexer-open (make-cipher cipher-algorithm/aes256
                                                        cipher-mode/cbc)
                                           hash-method/sha256
                                           hash-method/sha1))
                 `(,(lambda ()
                      (values (make-zlib-zip-filter)
                              (make-zlib-unzip-filter))))))

(define (store-directory dir store)
  "Serialize DIR, write it to STORE, and return its index tuple."
  (define pipeline
    ;; The pipeline suitable for directories in this s-exp format.
    %text-storage-pipeline)

  (let* ((str   (call-with-output-string (cut write-directory dir <>)))
         (index (run-storage-pipeline pipeline
                                      (mem-stream-open (string->utf8 str))
                                      store)))
    (pipeline-index-handle->tuple pipeline index)))

(define worthless-file?
  (let ((rx   (make-regexp "(\\.(o|lo|a|so|gcda|gcno|gcda\\.info)|~)$"))
        (dirs '(".libs" "CVS" ".svn")))
    (lambda (file-name stat)
      "Return true if FILE-NAME and STAT designate a worthless file or
directory."
      (case (stat:type stat)
        ((directory)
         (member file-name dirs))
        (else
         (regexp-exec rx file-name))))))

(define (run-storage-pipeline/recursive pipeline dir store)
  "Store directory DIR into STORE using PIPELINE and return its index
handle."

  ;; TODO: Replace PIPELINE with a FILE -> STAT -> PIPELINE procedure and
  ;; make WORTHLESS-FILE? a parameter.

  (define (stat->cached-entry stat)
    ;; Return an mtime/tuple pair corresponding to STAT or #f.
    (let* ((ino   (stat:ino stat))
           (dev   (stat:dev stat))
           (entry (false-if-exception
                   (store-read-block %file-index-mapping
                                     (string->utf8
                                      (format #f "(~a . ~a)" ino dev))))))
      (and entry
           (call-with-input-string (utf8->string entry) read))))

  (define (stat->index-tuple stat)
    ;; Return the serialized index tuple corresponding to STAT or #f.
    (match (stat->cached-entry stat)
      ((mtime . index-tuple)
       (and (= mtime (stat:mtime stat))
            index-tuple))
      (_ #f)))

  (define (cache-index stat index)
    (let* ((ino   (stat:ino stat))
           (dev   (stat:dev stat))
           (mtime (stat:mtime stat))
           (key   (format #f "(~a . ~a)" ino dev)))
      (store-write-block %file-index-mapping
                         (string->utf8 key)
                         (string->utf8
                          (format #f "(~a . ~s)" mtime index)))))

  (define (store/cache stat file)
    (define input
      (case (stat:type stat)
        ((symlink)
         (mem-stream-open (string->utf8 (readlink file))))
        ((regular) file)
        (else
         (warn "file `~a' of type `~a' will not be saved"
               file (stat:type stat))
         #f)))

    (and input
         (let* ((index  (run-storage-pipeline pipeline input store))
                (index* (pipeline-index-handle->tuple pipeline index)))
           (cache-index stat index*)
           index*)))

  (define (store-directory* stat entries)
    ;; Like `store-directory', and update %FILE-INDEX-MAPPING with a mapping
    ;; from STAT to the index tuple of ENTRIES.
    (let* ((prev  (and=> (stat->cached-entry stat) cdr))
           (dir   (make-directory prev entries))
           (index (store-directory dir store)))
      (cache-index stat index)
      index))

  (define (tip-exists? index)
    ;; Return #t if the root block pointed to by INDEX exists.
    (let-values (((index indexer fetcher)
                  (deserialize-index-tuple/ascii index)))
      (false-if-exception (block-fetcher-fetch fetcher index store))))

  (define (enter-directory? dir-name stat result)
    ;; Return #t when we want to enter directory DIR-NAME.  Note that we
    ;; enter DIR-NAME even if its mtime didn't change because a directory's
    ;; mtime is typically updated only when files are added or removed, not
    ;; when they are modified.
    (not (worthless-file? dir-name stat)))

  (define (process-file file stat result)
    ;; Return RESULT augmented with FILE's meta-data, taken from STAT, and
    ;; its index tuple in STORE.  As a side-effect, store FILE to STORE if it
    ;; isn't there already.
    (if (worthless-file? file stat)
        result
        (let ((index
               (if (= (stat:size stat) 0)
                   #f
                   (or (match (stat->index-tuple stat)
                         (((stream-filters ...) index (store-filters ...))
                          (and (tip-exists? index)
                               (list stream-filters index store-filters)))
                         (_ #f))
                       (store/cache stat file)))))
          (match result
            (((entries ...) result ...)
             (cons (cons (make-directory-entry (basename file)
                                               (stat:type stat)
                                               (stat:mtime stat)
                                               (stat:size stat)
                                               (stat:perms stat)
                                               index)
                         entries)
                   result))))))

  (define (enter-directory dir stat result)
    ;; Add to RESULT an empty list that will hold DIR's contents.
    (cons '() result))

  (define (leave-directory dir stat result)
    ;; Collect from the head of RESULT the file/index returned by
    ;; `process-file' for each file under DIR, and replace them with DIR's
    ;; meta-data/index-tuple.  As a side-effect, store DIR's contents to
    ;; STORE.
    (match result
      (((entries ...) (siblings ...) result ...)
       (cons (cons (make-directory-entry (basename dir)
                                         (stat:type stat)
                                         (stat:mtime stat)
                                         (stat:size stat)
                                         (stat:perms stat)
                                         (store-directory* stat entries))
                   siblings)
             result))))

  (define (skip-directory dir stat result)
    ;; Skip DIR, because it was considered worthless.
    result)

  (let ((result
         (file-system-fold enter-directory?
                           process-file
                           enter-directory
                           leave-directory
                           skip-directory
                           '(())
                           dir)))
    (match result
      ((((? directory-entry? dir)))
       (directory-entry-tuple dir)))))


;;;
;;; Retrieval.
;;;

(define* (list-directory-contents store tuple port
                                  #:key (verbose? #f) (recursive? #t)
                                        (history? #f))
  "Write to PORT, in a human-readable way, the contents of the directory at
TUPLE in STORE."
  ;; FIXME: Reuse `file-system-fold'.

  (define (nest indent)
    (string-append indent "    "))

  (define (->date epoch)
    (let ((date (time-monotonic->date (make-time time-monotonic 0 epoch))))
      (date->string date "~b ~e ~H:~M")))

  (define (->perms perms)
    (define (one perms)
      (string-append (if (bit-set? 2 perms) "r" "-")
                     (if (bit-set? 1 perms) "w" "-")
                     (if (bit-set? 0 perms) "x" "-")))
    (string-append (one (arithmetic-shift perms -6))
                   (one (logand 7 (arithmetic-shift perms -3)))
                   (one (logand 7 perms))))

  (define (display-entry entry indent)
    (format port "~a~a~a ~8,d ~16,a ~a~:[~*~; ~s~]~%"
            indent
            (case (directory-entry-kind entry)
              ((regular) "-")
              ((directory) "d")
              ((symlink) "l")
              ((block-special) "b")
              ((char-special) "c")
              ((fifo) "f")
              ((socket) "s")
              (else "?"))
            (->perms (directory-entry-permissions entry))
            (directory-entry-size entry)
            (->date (directory-entry-mtime entry))
            (directory-entry-name entry)
            verbose? (directory-entry-tuple entry)))

  (define (tuple->directory tuple)
    ;; Fetch the directory at TUPLE and return it.
    (let ((retrieve (index-tuple->retriever tuple)))
      (read-directory (retrieve store))))

  (define (make-previous-version-entry prev)
    (make-directory-entry "//previous-version//"
                          'directory
                          0 0 0
                          prev))

  (let loop ((tuple   tuple)
             (indent  "")
             (visited vlist-null))                ; tuples of visited dirs
    (define (visited? tuple)
      (vhash-assoc tuple visited))

    ;; Avoid visiting the same directory several times---useful when
    ;; RECURSIVE? and HISTORY? are both true.
    (or (and (visited? tuple) visited)
        (let* ((dir  (tuple->directory tuple))
               (prev (directory-previous-version dir)))
          (if (and (not history?) prev)
              (display-entry (make-previous-version-entry prev) indent))

          (let ((visited
                 (let liip ((entries (directory-entries dir))
                            (visited visited))
                   (or (and (null? entries) visited)
                       (let ((e (car entries)))
                         (display-entry e indent)
                         (liip (cdr entries)
                               (if (and (eq? 'directory
                                             (directory-entry-kind e))
                                        recursive?)
                                   (loop (directory-entry-tuple e)
                                         (nest indent)
                                         (vhash-cons tuple #t visited))
                                   visited)))))))

            (if (and history? prev)
                (begin
                  (display-entry (make-previous-version-entry prev) indent)
                  (loop prev (nest indent)
                        (vhash-cons tuple #t visited)))
                visited))))))

(define (dump-port in out)
  "Read as much data as possible from IN and write it to OUT."
  (define buffer-size 4096)
  (define buffer
    (make-bytevector buffer-size))

  (let loop ((bytes (get-bytevector-n! in buffer 0 buffer-size)))
    (or (eof-object? bytes)
        (begin
          (put-bytevector out buffer 0 bytes)
          (loop (get-bytevector-n! in buffer 0 buffer-size))))))

(define (restore-tree store tuple dir)
  "Read the directory pointed to by TUPLE from STORE and restore it under
directory DIR."
  (mkdir dir)
  (let loop ((tuple tuple)
             (dir   dir))
    (let ((retrieve (index-tuple->retriever tuple)))
      (let liip ((entries (directory-entries
                           (read-directory (retrieve store)))))
        (or (null? entries)
            (eof-object? entries)
            (let* ((e     (car entries))
                   (name  (directory-entry-name e))
                   (perms (directory-entry-permissions e))
                   (tuple (directory-entry-tuple e))
                   (file  (string-append dir "/" name)))
              (case (directory-entry-kind e)
                ((directory)
                 (let ((subdir file))
                   (mkdir subdir)
                   (chmod subdir perms)
                   (loop tuple subdir)
                   #t))
                ((regular)
                 (let ((out (open-output-file file)))
                   (if tuple                      ; #f means "empty file"
                       (let ((get (index-tuple->retriever tuple)))
                         (dump-port (get store) out)
                         (close out)
                         (chmod file perms)))
                   (close out)
                   (chmod file perms)
                   #t))
                ((symlink)
                 (let ((get (index-tuple->retriever tuple)))
                   (symlink (call-with-output-string
                             (cute dump-port (get store) <>))
                            file)
                   #t))
                (else
                 (warn "file `~a' of type `~a' not restored"
                       file (directory-entry-kind e))
                 #t))
              (liip (cdr entries))))))))


;;;
;;; Command-line entry point.
;;;

(define (show-help)
  (format #t "chop-backup [OPTION] STORE ARGS ...
Create or access an encrypted file system snapshot.

  -b, --backup           Create an encrypted backup of the given files or
                         directories, store it in file STORE, and return
                         a tuple that designates the backup.  This is the
                         default action.

  -l, --list[=OPTS]      List the contents of the directory pointed to by the
                         tuple specified in ARGS and stored at STORE.  OPTS
                         is a comma-separated list of long or one-letter
                         options: \"r\" or \"recursive\",\"f\" or \"flat\",
                         \"h\" or \"history\", \"l\" or \"latest\",
                         \"v\" or \"verbose\", \"c\" or \"concise\".

  -s, --show             Retrieve from STORE and show the contents pointed to
                         by the given tuple.

  -r, --restore          Retrieve from STORE and restore the complete file
                         system hierarchy pointed to by the given tuple, and
                         write it to the given directory.

  -h, --help             Give this help list
  -V, --version          Print program version

Report bugs to ~a.~%"
          (libchop-bug-address)))

(define (show-version)
  (format #t "chop-backup (libchop) ~a\n" (libchop-version)))

(define (leave fmt . args)
  (apply format (current-error-port) (string-append fmt "~%") args)
  (exit 1))

(define (write* obj)
  (write obj)
  (newline)
  obj)

(define %options
  (list (option '(#\h "help") #f #f
                (lambda args
                  (show-help)
                  (exit 0)))
        (option '(#\V "version") #f #f
                (lambda args
                  (show-version)
                  (exit 0)))

        (option '(#\b "backup") #f #f
                (lambda (opt name arg result)
                  (alist-cons 'action 'backup
                              (alist-delete 'action result eq?))))
        (option '(#\l "list") #f #t
                (lambda (opt name arg result)
                  (define canonical-options
                    (fold (lambda (opt result)
                            (case opt
                              ((r recursive)
                               (cons 'recursive result))
                              ((f flat)
                               (delq 'recursive result))
                              ((h history)
                               (cons 'history result))
                              ((l latest)
                               (delq 'history result))
                              ((v verbose)
                               (cons 'verbose result))
                              ((c concise)
                               (delq 'verbose result))
                              (else result)))
                          '()
                          (if arg
                              (map string->symbol
                                   (string-split arg #\,))
                              '())))

                  (alist-cons 'list-options canonical-options
                              (alist-cons 'action 'list result))))
        (option '(#\s "show") #f #f
                (lambda (opt name arg result)
                  (alist-cons 'action 'show
                              (alist-delete 'action result eq?))))
        (option '(#\r "restore") #f #f
                (lambda (opt name arg result)
                  (alist-cons 'action 'restore
                              (alist-delete 'action result eq?))))))

(define %default-options
  '((arguments . ())))

(define (main . args)
  "Backup FILE and EXTRA-FILES, recursively, to STORE-FILE.  Return an index
tuple that can be used to restore the whole directory hierarchy."
  (define (parse-args args)
    (args-fold args %options
               (lambda (opt name arg result)
                 (leave "~A: unrecognized option" opt))
               (lambda (arg result)
                 (alist-cons 'arguments
                             (cons arg
                                   (assq-ref result 'arguments))
                             (alist-delete 'arguments result
                                           eq?)))
               %default-options))

  (define (open-store file)
    (file-based-block-store-open (lookup-class "fs_block_store")
                                 file
                                 (logior O_CREAT O_RDWR) #o644))

  (define (backup store-file files)
    (catch 'chop-error
      (lambda ()
        (let ((store (open-store store-file)))
          (match files
            ((file)
             (let* ((file  (canonicalize-path file))
                    (tuple (run-storage-pipeline/recursive %default-storage-pipeline
                                                           file store)))
               (save-backup-tuple file tuple)
               (write* tuple)))
            ((files ...)
             (let* ((files  (map canonicalize-path files))
                    (stats  (map lstat files))
                    (tuples (map (cut run-storage-pipeline/recursive
                                      %default-storage-pipeline <> store)
                                 files))
                    (entries (map (match-lambda
                                   ((file stat tuple)
                                    (make-directory-entry (basename file)
                                                          (stat:type stat)
                                                          (stat:mtime stat)
                                                          (stat:size stat)
                                                          (stat:perms stat)
                                                          tuple)))
                                  (zip files stats tuples)))

                    ;; Aggregate all of FILES as if it were a single directory.
                    (tuple  (store-directory (make-directory #f entries)
                                             store)))
               (map save-backup-tuple files tuples)
               (write* tuple))))))
      (lambda (key err . _)
        (leave "error: ~a" (error-message err)))))

  (define (show store-file tuple)
    (let* ((store    (open-store store-file))
           (retrieve (index-tuple->retriever tuple))
           (port     (retrieve store)))
      (dump-port port (current-output-port))
      (store-close store)))

  (false-if-exception (setlocale LC_ALL ""))
  (let* ((options (parse-args args))
         (action  (or (assq-ref options 'action) 'backup))
         (args    (reverse (assq-ref options 'arguments))))

    (case action
      ((backup)
       (match args
         ((store-file files ...)
          (backup store-file files))
         (_
          (leave "too few arguments for `backup' operation"))))

      ((list)
       (let ((opts (or (assq-ref options 'list-options) '())))
         (match args
           ((store-file tuple)
            (list-directory-contents (open-store store-file)
                                     (with-input-from-string tuple read)
                                     (current-output-port)
                                     #:verbose? (memq 'verbose opts)
                                     #:recursive? (memq 'recursive opts)
                                     #:history? (memq 'history opts)))
           ((store-file)
            (match (most-recent-backup-tuple)
              (((? string? name) . tuple)
               (warn "accessing most recent backup of `~a' at `~s'"
                     name tuple)
               (list-directory-contents (open-store store-file)
                                        tuple
                                        (current-output-port)
                                        #:verbose? (memq 'verbose opts)
                                        #:recursive? (memq 'recursive opts)
                                        #:history? (memq 'history opts)))
              (_
               (leave "please specify the tuple of a directory"))))
           (_
            (leave "wrong number of arguments for the `list' operation")))))

      ((show)
       (match args
         ((store-file tuple)
          (show store-file (with-input-from-string tuple read)))
         ((store-file)
          (match (most-recent-backup-tuple)
            (((? string? name) . tuple)
             (warn "accessing most recent backup of `~a' at `~s'" name tuple)
             (show store-file tuple))
            (_
             (leave "please specify the tuple of a directory"))))
         (_
          (leave "wrong number of arguments for the `show' operation"))))

      ((restore)
       (match args
         ((store-file tuple out-dir)
          (let ((store (open-store store-file))
                (tuple (with-input-from-string tuple read)))
            (restore-tree store tuple out-dir)))
         ((store-file out-dir)
          (match (most-recent-backup-tuple)
            (((? string? name) . tuple)
             (warn "restoring most recent backup of `~a' at `~s'" name tuple)
             (restore-tree (open-store store-file) tuple out-dir))
            (_
             (leave "please specify the tuple of a directory"))))
         (_
          (leave "wrong number of arguments for the `restore' operation"))))
      (else (error "what's this?" action)))))
