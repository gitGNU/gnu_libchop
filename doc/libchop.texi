\input texinfo  @c -*-texinfo-*-

@c %**start of header
@setfilename libchop.info
@settitle Libchop, A Library for Distributed Storage and Data Backup
@footnotestyle end
@setchapternewpage odd
@c %**end of header

@include version.texi

@ifinfo
@dircategory Development
@direntry
* libchop: (libchop).      The libchop data storage library.
@end direntry

@dircategory Archiving
@direntry
* chop-backup: (libchop)Invoking chop-backup
                           Encrypted data backup.
@end direntry

Copyright @copyright{} 2010, 2011  Ludovic Court@`es
Copyright @copyright{} 2005, 2006  Centre National de la Recherche Scientifique (LAAS-CNRS)

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts.  A copy of the license is included in the section entitled ``GNU
Free Documentation License''.
@end quotation
@end ifinfo

@titlepage
@title{Libchop User's Guide}
@sp 0.5
@subtitle Applications & Library for Data Backup and Distributed Storage
@c @subtitle for libchop @value{VERSION}
@author Ludovic Court@`es

@page
@vskip 0pt plus 1filll
Edition @value{EDITION} @*
@value{UPDATED} @*

Copyright @copyright{} 2010, 2011  Ludovic Court@`es @*
Copyright @copyright{} 2005, 2006  Centre National de la Recherche Scientifique (LAAS-CNRS)

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts.  A copy of the license is included in the section entitled ``GNU
Free Documentation License''.
@end quotation
@end titlepage

@contents

@c *********************************************************************
@node Top
@top Libchop

This document describes libchop version @value{VERSION}.

@menu
* Introduction::                Rationale and overview.
* Utilities::                   Command-line interface to libchop.
* API Reference::               Using libchop from C.
* Guile Bindings::              Using libchop from GNU Guile.
* References::                  Worthy readings and related software.
* GNU Free Documentation License::  The license of this manual.
* Concept Index::               Concepts.
* Function Index::              Functions.
@end menu

@node Introduction
@chapter Introduction

Libchop is a set of utilities and library for data backup and
distributed storage.  Its main application is an encrypted backup
program with support for versioning, selective sharing, and adaptive
compression (@pxref{Invoking chop-backup}).

The library itself was initially designed as the basis for a peer-to-peer,
cooperative backup system.  In such a system, data has to be sent by
pieces, incrementally, and it may be scattered across several
participating nodes.  In addition, participating nodes may be untrusted,
which puts data confidentiality, integrity, and availability at risk.

In a nutshell, libchop addresses these issues by providing mechanisms
to:

@enumerate
@item
chop an input file into blocks, optionally compressed and/or encrypted,
and to store them into a key-value store.  It returns an @dfn{abstract
index} containing all the information necessary to retrieve the file.

@item
restore (rebuild) a file based on an abstract index, reading blocks from
one (or several) stores.  Each block is decoded, deciphered,
decompressed, and its integrity is checked according to the methods
specified by the abstract index.
@end enumerate

Libchop decomposes these tasks with a fine grain, providing generic
interfaces for each of the sub-tasks involved.  It also comes with
several implementations of each of these interfaces, allowing various
storage strategies to be quickly experimented and compared.
Implementations of these interfaces provide storage techniques such as
content-based addressing and single-instance storage, content-hash keys,
lossless compression, and similarity detection.

The following section gives an overview of the various interfaces and
how they fit together.  The next one gives an insight on typical use
cases of the techniques and algorithms implemented by libchop.

@menu
* Overview::                    What libchop provides.
* Use Cases::                   Applications of libchop.
@end menu

@node Overview
@section Overview

@cindex storage pipeline
@cindex pipeline
@cindex index handle
@cindex abstract index

The libchop library defines several fine-grain interfaces for file chopping and
indexing.  Objects implementing those interfaces may be composed
together to form a @dfn{data storage pipeline}: the input of this
pipeline are the raw contents of a file, and its output is a set of data
blocks and an @dfn{index handle}@footnote{In this document the terms
@dfn{abstract index} and @dfn{index handle} are used interchangeably to
describe indices are returned by a block indexer.} that suffices to
restore the file contents from those blocks.

The interfaces that allow components to interact altogether within
this framework are the following:

@itemize
@cindex stream
@item the @dfn{stream} interface, which delivers input data (e.g., file
contents) as a stream;
@cindex chopper
@item the @dfn{chopper} interface, given an input stream, splits this
input and returns block(s);
@cindex block indexer
@item the @dfn{block indexer} (resp. the @dfn{block fetcher}) interface
deals with the naming and storage a single data block (resp. the
retrieval of a single data block given its name);
@cindex stream indexer
@cindex indexer
@item the @dfn{stream indexer} is responsible for the
storage of a series of data blocks along with meta-data describing how
these blocks relate to each other; when retrieving a byte stream, the
stream indexers reads the meta-data and assembles data blocks
accordingly;
@cindex block store
@cindex store
@item the @dfn{block store} is an interface for the storage of key/data
pairs, allowing the contents of data blocks to be associated with a key.
@end itemize

The data flow in a stream indexing pipeline will look like this:

@verbatim
                       ,--  block indexer --.
                       |         ^          |
                       v         |          |
stream ----> chopper --+-> stream indexer --+-> block store
@end verbatim

It is worth noting that the block indexer has a central position
because it both stores data block directly to the block store, and
produces meta-data (individual block indices) which is fed back to the
stream indexer in order to be eventually stored and indexed as if it
were ``normal'' data.

When doing the opposite operation, i.e., restoring a data stream, the
data flow looks like this:

@verbatim
                        ,-------------------.
                        |                   |
                        v                   |
block store ----> block fetcher ----> stream indexer ----> byte stream
@end verbatim

Here, the stream ``indexer'' (actually a stream
@emph{fetcher}@footnote{For design reasons, there is actually one
interface (class) for both the stream indexer and the stream fetcher,
while the block indexer and block fetcher interfaces are represented
by two separate classes.  Conceptually, indexing and fetching are
really two distinct functions in both cases.  They are, however,
@emph{dual} functions, and may share code.}) is controlled by the user
(who provided the @dfn{index handle} of the stream to be retrieved).
The stream indexer, in turns, controls the block fetcher in order to
retrieve individual blocks from the underlying block store.

For each of these interfaces, libchop provides several
implementations.  Therefore, the user can conveniently choose the
pipeline configuration that fits them best.

@cindex filter
@cindex filtered stream
@cindex filtered block store
@findex chop_filtered_stream_open
@findex chop_filtered_store_open
Additionally, it is sometimes useful to @dfn{filter} input streams or
input/output blocks, pretty much in the same way one uses ``pipes''
under Unix.  Libchop provides a number of filters that may be used for
this purpose, such as zlib/bz2 unzip/zip filters, or public-key
ciphering filters.  The user can then create a filtered stream (via
@code{chop_filtered_stream_open ()}) or a filtered block store (via
@code{chop_filtered_store_open ()}) in order to make use of them
(@pxref{Filters}).

The storage pipeline can also be built and used from the command-line
using the @code{chop-archiver} tool (@pxref{Invoking chop-archiver}).

@node Use Cases
@section Use Cases

File chopping and indexing techniques are used in a wide range of
applications, including distributed storage, peer-to-peer file sharing,
archival, backup, and revision control.  Each of these classes of
application has specific requirements, and each particular design in
these classes has its own particularities.

Libchop, as a library or using its stand-alone utilities, can be used to
build such applications, as demonstrated by @command{chop-backup}
(@pxref{Invoking chop-backup}).  For instance, incremental encrypted
data backup to an untrusted site can be achieved this way:

@smallexample
# Mount the target FTP directory (using a GNU/Hurd translator; on
# GNU/Linux, `curlftpfs' and `sshfs' can be used similarly.)
$ settrans -ca backup-site /hurd/ftpfs ftp.example.com:backup

$ chop-backup backup-site /pix/holidays
(() "tree_indexer:chk_block_fetcher:chk_index_handle:100:aes256,cbc,sha1...agfq2a/4a" ())
@end smallexample

The long line displayed by @code{chop-backup} is an @dfn{index handle}
or @dfn{tuple} that can eventually be passed to @code{chop-backup
--restore} to restore the directory tree.  Although the directory and
its contents are stored as a set of encrypted blocks, it can be
@dfn{shared}: knowing the index handle is necessary and sufficient to
retrieve the file.  For more information, @pxref{Invoking chop-backup},
and @ref{Invoking chop-archiver}.

Anonymous peer-to-peer file sharing systems like GNUnet and FreeNet both
use the same particular configurations of the storage pipeline
(@pxref{References, GNUnet}).  Roughly, they use a fixed-size stream
chopper (e.g., in GNUnet 0.7, input files are chopped into 32 kB blocks)
and some form of a CHK@footnote{@dfn{CHK} means ``content-hash key''.
@xref{Stream Choppers}, for details.} block indexer.  GNUnet uses a
tree stream indexer.  In GNUnet, this whole encoding configuration is
called @dfn{ECRS}.  The Tahoe-LAFS distributed file system uses similar
techniques, with the addition of erasure coding as the ``chopper'', an
option currently not available in libchop (@pxref{References,
Tahoe-LAFS}).  Obviously, these projects use a completely distributed
block store underneath.

The @dfn{write-once read many} (WORM) archival system Venti (used in
Plan 9) uses a tree indexer and a content-based block indexer.  Venti
chops files into fixed-size blocks (@pxref{References, Venti}).

Recent distributed version control systems (such as Monotone, Git,
Mercurial, Bazaar, etc.) typically do not cut file into pieces.
Therefore, they do not require a stream indexer since each input file
yields one block.  However, they index files using a content-based block
indexer, which guarantees single-instance storage and integrity
verification.

Rsync uses content-based indexing as well in order to reduce the
amount of data to be transferred when synchronizing copies of a set of
files across different machines over the network.

Libchop is modular, which makes it possible to combine various storage
techniques such as those described above.  For a detailed discussion of
the trade-offs involved, @ref{References, Documents related to libchop}.

@c *********************************************************************
@node Utilities
@chapter Utilities

Libchop comes with a number of utilities that exercise all its API.

The first one, @command{chop-backup}, is an encrypted backup
application, with some bells and whistles.

The remaining tools offer a lower-level interface.  Using them is
actually a good way to become familiar with libchop's interfaces and
their implementations.

The @command{chop-archiver} tool exposes all of libchop's storage
pipeline, which makes it the main entry point to libchop from the
command line.  The @code{chop-block-server} program implements a dumb
@dfn{block server}, which listens to remote procedure calls (RPCs) to
read and write data blocks.

@menu
* Invoking chop-backup::        Encrypted, versioned backups.
* Invoking chop-archiver::      Storing and restoring data using libchop.
* Invoking chop-block-server::  Remote data block storage.
@end menu

@node Invoking chop-backup
@section Invoking @command{chop-backup}

@cindex backup
@cindex chop-backup
@command{chop-backup} is an encrypted backup application@footnote{This
utility is installed only when GNU Guile 2.0 is available.}.  It is
designed to liberate users from the need to entrust their storage
providers with data confidentiality, integrity, and availability.  We
believe this should make users less dependent on any storage providers,
while making it easier to share storage capacity among distrustful
people or organizations.

The tool has several salient features towards that goal:

@table @emph
@item Encrypted.
The backup data can safely be store at an untrusted site without
compromising its confidentiality.

@item Tamper-proof.
The backup's integrity is checked upon recovery.

@item Distributable.
Backup data can be written to more than one store.

@item Shareable.
@cindex capabilities
@cindex principle of least authority (POLA)
Each directory/file in a snapshot is identified by a ``tuple'', which is
necessary and sufficient to retrieve it.  A tuple can be shared with
others, which gives them access to the corresponding file/directory and
@emph{only} it---in accordance with the principle of least
authority@footnote{Tuples can be thought of as
@dfn{capabilities}---i.e., ``unforgeable'', opaque bit strings that
designate content @emph{and} the right to access it.  Tuples are
``protected by sparsity'', whereas capabilities in operating systems or
programming languages are typically ``kernel-protected''.}.

@item Versioned.
@cindex versioning
The history of directory snapshots is recorded, at little cost.

@item Compressed.
@cindex deduplication
@cindex single-instance storage
Similar data among files or versions are coalesced (this is sometimes
referred to as @dfn{deduplication} or @dfn{single-instance storage}).
For each file type an appropriate compression method is chosen.

@item Evolutive.
The application is not bound to any storage, hash, encryption, or
compression method.  In fact, all these parameters can vary from file to
file within a snapshot.
@end table

@noindent
To create a snapshot, type:

@example
$ chop-backup --backup ~/bak ~/doc/important
(() "tree_indexer:chk_block_fetcher:chk_index_handle:100:aes256,cbc,sha1...mdfagfq2a/4a" ())

$ chop-backup --backup /net/backup-machine ~/doc/important
(() "tree_indexer:chk_block_fetcher:chk_index_handle:100:aes256,cbc,sha1...ssqijsady/4a" ())
@end example

@cindex tuple
@noindent
The first command above creates a snapshot of the @file{~/doc/important}
directory and stores it under @file{~/bak}.  Upon completion it displays
a @dfn{tuple}, which is the key that is @emph{necessary and sufficient}
to access the snapshot.  The second command writes a new (possibly
identical) snapshot to @file{/net/backup-machine}, which could be (say)
an SSHFS mount point to some backup host.

Because the returned tuples are so important (and hard to type),
@command{chop-backup} caches a copy of them locally.  They can be
accessed with the @code{--recent} option:

@example
$ chop-backup --recent
/home/ludo/doc/important        (() "tree_indexer...ssqijsady/4a" ())
@end example

To allow you to retrieve your data even if the host on which
@command{chop-backup} is run crashes, it is recommended to backup the
resulting tuple by other means---e.g., by sending it by mail.

The contents of a snapshot can be listed:

@example
$ chop-backup --list ~/bak
accessing most recent backup of `/home/ludo/doc/important' at `(() "tree_...gfq2a/4a" ())'
d---------        0 Jan  1 01:00     //previous-version//
drwxr-xr-x     4096 Oct  6 22:18     chop
-rw-r--r--    32001 Oct  6 22:35     Makefile
-rw-r--r--     1451 Dec  8 10:23     Makefile.am
-rw-r--r--       59 Dec  8 10:23     .gitignore
-rw-r--r--    38221 Oct  6 22:20     Makefile.in
@end example

@noindent
Since the command did not specify a tuple, @command{chop-backup} assumed
that the user may be interested in the latest backup that was made.

The special entry @code{//previous-version//} above represents the
previous snapshot of that directory.  The code @code{--list=verbose}
option would show its tuple, which could then be passed to
@command{chop-backup --list} to view specifically that version.

Complete directory trees can be restored:

@example
$ chop-backup --restore ~/bak out
@end example

This command restores the latest snapshot and writes it to directory
@file{out}, preserving file permissions and symbolic links.

For each action, @command{chop-backup} has a corresponding option, as
seen above.  The list of options is described below.

@table @option
@item --backup
@itemx -b
Create an encrypted backup of the given directories, store it in the
specified block store, and return a tuple that designates the backup.

For this action, @command{chop-backup} must be passed at least two
arguments: a file name for the backup store, and one or more directories
to be backed up.  This is the default action.

@item --recent
@itemx -R
List recent backups and their tuple.  For each backup, a line is shown
with the original directory name and the tuple of its latest backup.

@item --list=[@var{opts}]
@itemx -l@var{opts}
List the contents of the directory pointed to by the specified tuple in
the specified store.

For this action, @command{chop-backup} must be passed at least the file
name of the store, and optionally the tuple of a directory snapshot.

@var{opts} is a comma-separated list of long or one-letter options:

@table @option
@item r
@itemx recursive
Show the contents of sub-directories, recursively.

@item f
@itemx flat
Do not recurse into sub-directories.

@item h
@itemx history
Show the contents of previous directory versions, recursively.  Each
directory version appears as if it were a sub-directory of the next
version, and called @file{//previous-version//}.

@item l
@itemx latest
Show only the latest directory version.

@item v
@itemx verbose
Show each file or directory tuple.

@item c
@itemx concise
Do not show tuples.
@end table

For instance, @command{chop-backup -lr,h ~/bak} lists the contents of
the most recent backup, recursively traversing sub-directories and
previous directory versions.

@item --show
@itemx -s
Show the contents pointed to by the given tuple in the given store.

For this action, @command{chop-backup} must be passed the store's file
name, and optionally a tuple.

@item --check
@itemx -c
Check whether the contents of the directory pointed to by the given
tuple are available from in the given store, recursively.  Each file is
marked as @code{OK}, @code{CORRUPT}, or @code{MISSING}; @code{MISSING}
means that some of the data blocks that comprise the given file were not
found in the store.

For this action, @command{chop-backup} must be passed the store's file
name, and optional a tuple pointing to a directory snapshot.

@item --restore
@itemx -r
Retrieve from the given store and restore the complete file system
hierarchy pointed to by the given tuple, and write it to the given
directory.

For this action, @command{chop-backup} must be passed the store's file
name, an optional tuple, and the output directory name.

@item --help
Print a summary of the command-line options and exit.

@item --version
Print the version number of libchop and exit.

@end table

@noindent
Under the hood, @command{chop-backup} uses content-hash keys---i.e., the
@code{chk_block_indexer}---to provide symmetric encryption and
single-instance storage (@pxref{Block Indexers & Fetchers}).  The rest
of the storage pipeline, notably choppers and compression filters, is
chosen as a function of the file type (text file, already-compressed
file, unknown file type).

@node Invoking chop-archiver
@section Invoking @code{chop-archiver}

@cindex @code{chop-archiver}

The @code{chop-archiver} tool is a @dfn{storage client} that exposes
most of the libchop programming interface at the command line.  It
stores and retrieves individual files through the libchop storage
pipeline (@pxref{Overview}).  Unlike @command{chop-backup}, it does not
natively support directory traversal and versioning; instead, it offers
a lower-level interface.  Users can choose each component of the
pipeline, thanks to libchop's introspection capabilities (@pxref{Object
System}).

The tool can be used in one of two modes:

@enumerate
@item
In @emph{archival mode}, with the @code{--archive} or
@code{--archive-fd} option, @code{chop-archiver} stores the given file
and returns the resulting index (@pxref{Block Indexers & Fetchers}):

@smallexample
$ chop-archiver --archive README
tree_indexer:hash_block_fetcher:hash_index_handle:64:sha1:6jmb3wrbzyqpsngxybt4r4rxtctdo4o2/26

$ chop-archiver --archive-fd=5 5< README
tree_indexer:hash_block_fetcher:hash_index_handle:64:sha1:6jmb3wrbzyqpsngxybt4r4rxtctdo4o2/26
@end smallexample

@cindex index handle
The above command stored the file @file{README} in a local block store
under @code{$HOME/.chop-archiver} and printed an @dfn{index} that can
later be used to restore the file.

@item
In @emph{retrieval mode}, with the @code{--restore} option,
@code{chop-archiver} retrieves data pointed to by the given index:

@smallexample
$ chop-archiver --restore \
    tree_indexer:hash_block_fetcher:hash_index_handle:64:sha1:6jmb3wrbzyqpsngxybt4r4rxtctdo4o2/26
@end smallexample

This command retrieves and decodes the data pointed to by the given index
and prints it on the standard output.  The integrity of each data block
is checked and an error is returned if one of the blocks has been
tampered with.

@end enumerate

The available options allow the customization of the storage process:

@example
chop-archiver --block-indexer sha256 -a README
@end example

The command above instructs @code{chop-archiver} to store the given file
with content-based addressing, using @code{sha256} hashes of individual
data blocks as their key.

@example
tar cf - /secret/things | \
chop-archiver -i chk_block_indexer -I aes256,cbc,sha256,sha1 -A
@end example

@cindex content-hash keys
@cindex CHK
@cindex encryption
This command uses content-hash keys (CHKs) to encrypt and name
individual data blocks.  Data blocks are encrypted with the
@code{aes256} symmetric cipher algorithm in @dfn{cipher block chaining}
mode; the encryption key is the @code{sha256} hash of the cleartext data
block.  Finally, the key associated with the resulting (encrypted) data
block is the @code{sha1} hash of that block.

@cindex similarity detection
The following command specifies that the input data should be chopped
into data blocks using an algorithm that chooses block boundaries so as
to facilitate similarity detection, trying to obtain blocks of 512 bytes
on average:

@example
chop-archiver --chopper anchor_based_chopper --block-size 512 -a README
@end example

Finally, @code{chop-archiver} can be told to use a remote block store
rather than a local on-disk store.  In that case requests to read and
write data blocks are sent as @dfn{remote procedure calls} (RPCs) over
the network:

@example
chop-archiver --remote `chop-store-discover -D1 | cut -f2` -a README
@end example

The above command sends data to whichever remote block store is found on
the local network (assuming Avahi was available at compile time).  An
implementation of a remote block store server is the
@code{chop-block-server} tool (@pxref{Invoking chop-block-server}).

The long list of available options follows:

@table @option
@item --archive=@var{file}
@itemx -a @var{file}
Archive @var{file} and print an @dfn{index handle}.  This index can be
used for later retrieval with the @code{--restore} option.

@item --archive-fd=[@var{fd}]
@itemx -A[@var{fd}]
Same as above, but reads data from @var{fd}, an open file descriptor, or
the standard input if @var{fd} is omitted.

@item --restore=@var{index}
@itemx -r @var{index}
Restore a file's revision from @var{handle}, an index handle pointing to
an archived data stream.

@item --block-size=@var{size}
@itemx -b @var{size}
Choose a typical size of @var{size} bytes for the blocks produced by the
chopper.

@item --chopper=@var{chopper}
@itemx -C @var{chopper}
Use an instance of the class named @var{chopper} as the input stream
chopper (@pxref{Stream Choppers}).

@item --db-file=@var{file}
@itemx -f @var{file}
Write the block database to @var{file}.  By default,
@code{chop-archiver} uses a block store under
@code{$HOME/.chop-archiver}.

@item --block-indexer-class=@var{bi-class}
@itemx -i @var{bi-class}
Use @var{bi-class} as the block-indexer class (@pxref{Block Indexers &
Fetchers}).  This implies @code{-I}.  By default @code{chop-archiver}
uses an instance of the @code{hash_block_indexer} class, which provides
content-based addressing without encryption.

@item --block-indexer=@var{bi}
@itemx -I @var{bi}
Deserialize @var{bi} as an instance of @var{bi-class} and use it.

@item --indexer-class=@var{i-class}
@itemx -k @var{i-class}
Use @var{i-class} as the indexer class (@pxref{Stream Indexers}).  This
implies @code{-K}.

@item --indexer=@var{i}
@itemx -K @var{i}
Deserialize @var{i} as an instance of @var{i-class} and use it.

@item --openpgp-pubkey=@var{pubkey-file}
@itemx -o @var{pubkey-file}
@itemx --openpgp-privkey=@var{privkey-file}
@itemx -O @var{privkey-file}
Use @var{pubkey-file} and @var{privkey-file} as the OpenPGP key pair to
be used during TLS mutual authentication.  The files should contain
base64-encoded OpenPGP keys.  This option is only available when GnuTLS
was detected at configure time.

@item --protocol=@var{proto}
@itemx -p @var{proto}
Use @var{proto} (one of @code{tls/tcp}, @code{tcp}, @code{udp} or
@code{unix}) when communicating with the remote store specified with
@code{--remote}.  Note that @code{tls/tcp} is only available when GnuTLS
was detected at configure time.

@item --remote=@var{host}
@itemx -R @var{host}
Use the remote block store located at @var{host} for both data and
meta-data blocks; @var{host} may contain @code{:} followed by a port
number.

@item --no-smart-store
@itemx -N
In archival mode, instruct @command{chop-archiver} to write data blocks
regardless of whether they already exist in the block store.

@cindex incremental storage
By default, only blocks not already available in the block store are
written@footnote{To determine whether a block is available,
@command{chop-archiver} checks whether @emph{something} is stored under
the block's name without checking whether the contents are the same.  It
makes sense for content-based addressing, e.g., with
@code{hash_block_indexer} and @code{chk_block_indexer}.}.  It makes
incremental storage very fast (e.g., when archiving a file that has
already been stored, or when storing a file that contains data similar
to what's already available in the store) and saves bandwidth when using
a remote block store.

@item --show-stats
@itemx -s
Show statistics about the blocks that have been written (in archival
mode).

@item --store=@var{class}
@itemx -S @var{class}
Use @var{class} as the underlying file-based block store (@pxref{Block
Stores}).

@item --zip[=@var{zip-type}]
@itemx -z@var{zip-type}
Pass data blocks through a zip filter to compress (resp. decompress)
data when writing (resp.  reading) to (resp. from) the archive
(@pxref{Filters}).  @var{zip-type} should be one of @code{zlib},
@code{bzip2}, or @code{lzo}.

@item --zip-input[=@var{zip-type}]
@itemx -Z@var{zip-type}
Same as above, except that the zip filter is applied to the input data
stream.

@item --debug
@itemx -d
Produce debugging output and use a dummy block store (i.e., a block
store that does nothing but print messages).

@item --verbose
@itemx -v
Produce verbose output.

@item --help
Print a help message.

@item --usage
Print a short usage message.

@item --version
@itemx -V
Print the program and libchop version.
@end table


@node Invoking chop-block-server
@section Invoking @code{chop-block-server}

@cindex @code{chop-block-server}

The @code{chop-block-server} tool is an ONC RPC server that serves
requests from the network to read and write data blocks.  It it similar
in spirit to Plan 9's Venti (@pxref{References, Venti}).  By default, it
is completely oblivious to the encoding and naming scheme of incoming
data blocks: it doesn't know what block indexer was used to index them,
doesn't require content-based indexing, and of course doesn't know how
these data blocks relate to each other.

The server is invoked like this:

@example
chop-block-server [@var{options}] @var{local-block-store}
@end example

This command starts a block store server listening to block store remote
procedure calls (RPCs) and applying them to the store from file
@var{local-block-store} (the type of store in this file is determined by
the @code{--store} option; see below.)  @var{options} can contain any
options from the following list:

@table @option
@item --help
Print a summary of the command-line options and exit.

@item --version
Print the version number of libchop and exit.

@item --address=@var{address}
@itemx -a @var{address}
Bind to @var{address} and listen to connections there.

@item --port=@var{port}
@itemx -p @var{port}
Run the service on port @var{port}.

@item --protocol=@var{proto}
@itemx -P @var{proto}
Serve RPCs over PROTO, either @code{tcp} or @code{udp}.

@item --no-collision-check
@itemx -C
Turn off block/key collision checks.  By default, when a request to
write a block under a given key is received, @code{chop-block-server}
returns an error if there's already a block associated with that key and
that block differs from the new one.

@item --enforce-hash=@var{algo}
@itemx -H
Enforce content-hash algorithm @var{algo}.  That is, return an error if
the key under which a block is to be written is not the @var{algo} hash
of this block.

@item --zip[=@var{zip-type}]
@itemx -z[@var{zip-type}]
Pass data blocks through a @var{zip-type} filter to compress
(resp. decompress) data when writing (resp. reading) to (resp. from) the
block store.  @var{zip-type} may be one of @code{zlib}, @code{bzip2}, or
@code{lzo}, for instance.

@item --service-name=@var{name}
@itemx -s @var{name}
Choose @var{name} as the service name to be published via Avahi.  This
option is only available when Avahi was detected at configure time.

@item --no-publication
@itemx -n
Turn off service publication on the LAN via Avahi.  This option is only
available when Avahi was detected at configure time.

@item --tls
@itemx -t
Use RPCs over TLS (recommended).  This option is only available when
GnuTLS was detected at configure time.

@item --openpgp-pubkey=@var{pubkey-file}
@itemx -o @var{pubkey-file}
@itemx --openpgp-privkey=@var{privkey-file}
@itemx -O @var{privkey-file}
Use the OpenPGP public key from @var{pubkey-file} and the corresponding
private key from @var{privkey-file} for TLS mutual authentication.
These files must contain a base64-encoded OpenPGP key.  These options
are available when GnuTLS was detected at configure time.

@item --store=@var{class}
@itemx -S @var{class}
Use @var{class} as the underlying file-based block
store (@pxref{Block Stores}).

@item --debug
@itemx -d
Produce debugging output and use a dummy block store (i.e., a block
store that does nothing but print messages).

@item --verbose
@itemx -v
Produce verbose output.

@end table

@c *********************************************************************
@node API Reference
@chapter API Reference

@c FIXME
This chapter is currently largely incomplete.  Please refer to the
documentation in the libchop header files.

@menu
* Object System::               Object, classes, serialization, etc.
* Input Streams::               
* Stream Choppers::             
* Block Stores::                
* Block Indexers & Fetchers::   
* Stream Indexers::             
* Filters::                     
@end menu

@c *********************************************************************
@node Object System
@section Object System

@cindex object system
Libchop comes with its own lightweight reflexive object system defined
in the @code{<chop/objects.h>} header file.  Given that it is a
reflexive object system, type information is available at run-time.
With little overhead, this object system greatly improves the
flexibility of the library.  The @code{chop-archiver} command line tool
illustrates how type introspection can be leveraged to provide more
flexibility (@pxref{Invoking chop-archiver}).

@cindex binary compatibility
Libchop's object system can be used to provide binary compatibility with
little overhead: the size of a given class' instances can be known at
run-time, which allows for caller allocation.  Callers can allocate
objects of a given class as they prefer (e.g., on the stack) while
remaining binary-compatible should the class layout
change.@footnote{Conversely, the Glib family of libraries achieves
binary compatibility at the cost of removing the possibility for caller
memory allocation: constructors do not only initialize an object, they
also allocate its storage on the heap.  The situation in C++ is often
similar, but C++ has the advantage of having compiler support.}

Let's have a closer look at it.

@menu
* Declaring and Defining a Class::  
* Instantiating an Object::     
* Cloning an Object::           
* Testing Objects for Equality::  
* Serializing and Deserializing an Object::  
@end menu

@node Declaring and Defining a Class
@subsection Declaring and Defining a Class

@cindex class

At run-time, libchop classes are represented by @code{chop_class_t}
objects.  The canonical naming scheme for classes is the following.
Let @code{chbouib} be a libchop class:

@itemize
@item its C type is named @code{chop_chbouib_t};
@item its run-time representation is a global @code{chop_class_t}
object named @code{chop_chbouib_class}.
@end itemize

Libchop defines macros to declare and define classes while maintaining
the naming scheme in a consistent way:

@defmac CHOP_DECLARE_RT_CLASS (name, parent_name, fields)
Declare a class named @var{name}, that is declare the type
@code{chop_NAME_t} and the global variable @code{chop_NAME_class}.
@var{fields} should be a list of fields (as in a @code{struct}
definition).  Note that libchop classes must always inherit (directly
or not) the @code{object} class.

Example:

@example
CHOP_DECLARE_RT_CLASS (chbouib, object,
                       int x;
                       float y;);
@end example

@end defmac

@defmac CHOP_DEFINE_RT_CLASS (name, parent_name, ctor, dtor, copy, equalp, serial, dserial)
Once the class named @var{name} has been declared, this macro defines
it as being a sub-class of the class named @var{parent_name} (this
must be the same name as the one used in the declaration!), with
constructor @var{ctor} and destructor @var{dtor} (both are optional),
and with copy constructor @var{copy} and equality predicate
@var{equalp} (both optional too).  Finally, @var{serial} is a pointer
to a serializer and @var{dserial} and pointer to a deserializer which
may both be @code{NULL} as well.
@end defmac

See the @code{<chop/objects.h>} for details.

@node Instantiating an Object
@subsection Instantiating an Object

Constructors, in libchop, do not allocate memory to store objects:
they simple @emph{initialize} objects.  Therefore, memory must be
allocated to store a given an object @emph{before} its constructor is
called.  Run-time type information turns out to be helpful here: each
@code{chop_class_t} object contains information about the amount of
memory needed to store an instance of it.

@deftypefun size_t chop_class_instance_size (const chop_class_t *class)
Return the size, in bytes, of instances of class @var{class}.
@end deftypefun

@defmac chop_class_alloca_instance (class)
Return a pointer to a memory area large enough to store an instance of
@var{class}.  This macro uses @code{alloca} to allocate storage on the
stack (see @inforef{Variable Size Automatic, the GNU libc manual,
libc}, for details).
@end defmac

@deftypefun chop_error_t chop_object_initialize (chop_object_t *object, const chop_class_t *class)
Initialize @var{object} as an instance of class @var{class}, thus
invoking the constructor of @var{class} and the one of its parent
classes.

As a user, you will not usually call this function directly.  Instead,
you will call a particular constructor for @var{class} that can take
additional arguments (e.g., @code{chop_file_stream_open ()}) and which
will in turn call this function behind the scenes.
@end deftypefun

@deftypefun void chop_object_destroy (chop_object_t *object)
Destroy @var{object}, that is deallocate resources associated to it.
Note that it does not deallocate the memory where @var{object} is
stored.
@end deftypefun

It is important to note that all libchop objects must be destroyed
using @code{chop_object_destroy ()}, regardless of where they are
stored in memory.

Another way to instantiate an object is described in @ref{Cloning an
Object}.


@node Cloning an Object
@subsection Cloning an Object

@cindex deep copy
@cindex clone
Libchop's object system allows @dfn{deep copies} or @dfn{cloning} of
objects.  Classes, however, may choose to not implement this feature.

@deftypefun chop_error_t chop_object_copy (const chop_object_t *source, chop_object_t *dest)
Clone the object pointed to by @var{source} into @var{dest}.  As
usual, @var{dest} must point to an (uninitialized) memory area large
enough to hold an instance of @var{source}'s class.  If @var{source}'s
class does not implement cloning, then a default ``shallow'' copy is
performed.

Note that, in any case, the copy constructors of the whole class
hierarchy of @var{source} are invoked, starting from the higher one,
just like for a regular instantiation (@pxref{Instantiating an
Object}).
@end deftypefun


@node Testing Objects for Equality
@subsection Testing Objects for Equality

@cindex equality predicate
Testing whether two objects are equal or not may be dependant on the
implementation of their classes.  Classes may implement an
@dfn{equality predicate} that can be used two compare two
instances@footnote{This is similar to Scheme's @code{equal?}
vs. @code{eq?} @inforef{Equivalence predicates, R5RS Equivalence
Predicates, r5rs}.}.

@deftypefun int chop_object_equal (const chop_object_t *o1, const chop_object_t *o2)
Return true (non-zero) if objects @var{o1} and @var{o2} are equal.  If
both objects are instances of the same class but that class does not
define an equality predicate, they will only be considered equal if
and only if @code{@var{o1} == @var{o2}}, from a pointer arithmetic
viewpoint.
@end deftypefun


@node Serializing and Deserializing an Object
@subsection Serializing and Deserializing an Object

@cindex serialization
@cindex deserialization
Classes in libchop may implement a @dfn{serialization} and a
@dfn{deserialization} methods---these methods may be specified at
class definition time (@pxref{Declaring and Defining a Class}).
A serialization method basically converts an object into a portable
representation of its state as a byte stream.  The deserialization
operation does the opposite.

The @code{chop_serial_method_t} type defines two standard
serialization/deserialization methods:

@table @code
@item CHOP_SERIAL_ASCII
An object is serialized using only ASCII characters.  This yields
human-readable representations.
@item CHOP_SERIAL_BINARY
An object is serialized using as a byte stream where each byte can
have any value.  This usually yields to significantly more compact
representations.
@end table

@deftypefun chop_error_t chop_object_serialize (const chop_object_t *object, chop_serial_method_t method, chop_buffer_t *buffer)
Serialize @var{object} according to serialization method @var{method}
into @var{buffer}.  If no serializer exists for @var{object}'s class,
@code{CHOP_ERR_NOT_IMPL} is returned.  On success, zero is returned.
@end deftypefun

@deftypefun chop_error_t chop_object_deserialize (chop_object_t *object, const chop_class_t *class, chop_serial_method_t method, const char *buffer, size_t size, size_t *bytes_read)
Initialize @var{object}, which is expected to be of type @var{class},
by deserializing @var{buffer} (of @var{size} bytes), according to
@var{method}.  On success, zero is returned and @var{object} is
initialized.  Otherwise, @var{object} is left in an undefined state.
On success, @var{bytes_read} is set to the number of bytes that were
read from @var{buffer} in order to deserialize @var{object}.
@end deftypefun


@node Input Streams
@section Input Streams

The @code{chop_stream_t} type provides a simple interface to input byte
streams.  Data is read on-demand using the @code{chop_stream_read ()}
function:

@deftp {Type} chop_stream_t
The type of an input byte stream.
@end deftp

@deftypevar chop_class_t chop_stream_class
The class object for instances of type @code{chop_stream_t}.
@end deftypevar

@deftypefun chop_error_t chop_stream_read (chop_stream_t *@var{stream}, char *@var{buffer}, size_t @var{size}, size_t *@var{read})
Read at most @var{size} bytes from @var{stream} into @var{buffer}.  On
failure, return an error code (non-zero).  Otherwise, return in
@var{read} the number of bytes actually read.
@end deftypefun

@deftypefun size_t chop_stream_preferred_block_size (const chop_stream_t *@var{stream})
Return the preferred block size for reading @var{stream}.  This gives
callers, such as choppers, a hint, which may improve read performance.
@end deftypefun

@subsection Input Stream Classes

Several classes implement @code{chop_stream_t}:

@deftypevar chop_class_t chop_file_stream_class
@deftypevarx chop_class_t chop_mem_stream_class
@deftypevarx chop_class_t chop_filtered_stream_class
Classes that inherit from @var{chop_stream_class}.
@end deftypevar

These classes implement input streams backed by files, in-memory byte
arrays, or by another stream passed through a filter (@pxref{Filters}).

To create instances of these classes, use the constructors below.

@deftypefun chop_error_t chop_file_stream_open (const char *@var{path}, chop_stream_t *@var{stream})
Open file located at @var{path} and initialize @var{stream} as a file
stream representing this file.  @var{stream} has to point to a
large-enough memory area to hold an object whose class is
@code{chop_file_stream_class}.
@end deftypefun

@deftypefun void chop_mem_stream_open (const char *@var{base}, size_t @var{size}, void (*@var{free_func}) (void *), chop_stream_t *@var{stream})
Open a memory-backed stream, i.e., a stream whose input is read from
@var{base} which is @var{size} byte-long.  If @var{free_func} is not
@code{NULL}, it is called upon closing @var{stream}.
@end deftypefun

@deftypefun chop_error_t chop_filtered_stream_open (chop_stream_t *@var{backend}, chop_proxy_semantics_t @var{bps}, chop_filter_t *@var{filter}, int @var{owns_filter}, chop_stream_t *@var{stream})
Initialize @var{stream} as a filtered stream that reads input data from
@var{backend} through @var{filter}.  @var{bps} defines the semantics of
@var{stream} as a proxy of @var{backend} (whether @var{backend} should
eventually be destroyed, etc.).  Similarly, if @var{owns_filter} is
true, then closing @var{stream} will destroy @var{filter}.
@end deftypefun

@node Stream Choppers
@section Stream Choppers

@node Block Stores
@section Block Stores

@node Block Indexers & Fetchers
@section Block Indexers & Fetchers

@node Stream Indexers
@section Stream Indexers

@node Filters
@section Filters


@c *********************************************************************
@node Guile Bindings
@chapter Guile Bindings

Libchop can be used in Scheme programs written for GNU Guile 2.0
(@pxref{Top,, GNU Guile, guile, GNU Guile Reference Manual}).  Each C
header file has a corresponding Guile module---e.g., the @code{(chop
indexers)} module corresponds to @code{<chop/indexers.h>}.  The
@code{(chop)} module is a composite module that aggregates all the
sub-modules.

The example below shows how one would write a procedure that, given a
file name, stores and encrypts the given file and returns an opaque
index handle (@pxref{Overview,, index handle}).

@lisp
(use-modules (chop))

(define (chop/encrypt file store)
  (let* ((input (file-stream-open file))
         (i     (tree-indexer-open))
         (c     (fixed-size-chopper-open input 777))
         (bi    (chk-block-indexer-open (make-cipher cipher-algorithm/aes256
                                                     cipher-mode/cbc)
                                        hash-method/sha256
                                        hash-method/sha1)))
    (indexer-index-blocks i c bi store store)))
@end lisp

To store an encrypted copy of a file, this procedure can be invoked as
follows:

@lisp
(let ((s (file-based-block-store-open (lookup-class "gdbm_block_store")
                                      "encrypted-data.gdbm"
                                      (logior O_RDWR O_CREAT)
                                      #o644)))
 (chop/encrypt "secret-file.txt" s))
@result{} #<chop chk_index_handle 346d1c0 (3475000)>
@end lisp

In this example, @file{secret-file.txt} is chopped into blocks of 777
bytes (@pxref{Stream Choppers}).  Those blocks are then encrypted and
stored in @file{encrypted-data.gdbm}, a GNU dbm key/value store
(@pxref{Intro,,, gdbm, GNU @code{dbm} Reference Manual}).

The returned index handle can be serialized as a string and stashed, for
later reuse:

@lisp
(serialize-object/ascii (chop/encrypt "secret-file.txt" s))
@result{} "ci4r7xyktacal3rqrf6wpk5kitripgrv3cxvllarepzzsus5mmuq====,6v4nej5hjmtkvcinlawcf24wnq4zplm7/64a"
@end lisp

Getting back an index handle from such a string is done this way:

@lisp
(let ((str "ci4r7xyktacal3rqrf6wpk5kitripgrv3cxvllarepzzsus5mmuq====,6v4nej5hjmtkvcinlawcf24wnq4zplm7/64a"))
  (deserialize-object/ascii (lookup-class "chk_block_indexer") str))
@result{} #<chop chk_index_handle 284ee40 (2854000)>
@end lisp

Finally, the procedure below returns a Scheme port from the given index
handle and block store:

@lisp
(define (decrypt/assemble index store)
  (let* ((i  (tree-indexer-open))
         (bi (chk-block-indexer-open (make-cipher cipher-algorithm/aes256
                                                  cipher-mode/cbc)
                                     hash-method/sha256
                                     hash-method/sha1))
         (bf (block-indexer-fetcher bi)))
    (stream->port (indexer-fetch-stream i index bf store store))))
@end lisp

The data pointed to by @var{index} in @var{store} can be obtained by
reading from the returned port.

And voil@`a!

The API reference is not written yet, but all the Scheme procedures come
with a @dfn{docstring}, and can be easily browsed using Geiser
(@pxref{Documentation helpers,,, geiser, Geiser}).


@c *********************************************************************
@node References
@chapter References

Free software related to libchop:

@table @asis

@item Plan 9's Venti archival storage server
@url{http://plan9.bell-labs.com/@/magic/@/man2html/@/8/@/venti}

@item GNUnet, GNU's decentralized anonymous and censorship-resistant peer-to-peer framework
@url{http://gnunet.org/}

@item Tahoe-LAFS, a secure, decentralized, data store
@url{http://allmydata.org/@/trac/@/tahoe-lafs}

@end table

Documents related to libchop:

@table @asis

@item Cooperative Data Backup for Mobile Devices
Ludovic Court@`es (PhD thesis), 2007,
@url{http://tel.archives-ouvertes.fr/@/tel-00196822/en/}.  Chapter 4
discusses the design of libchop.  It contains an evaluation of several
storage strategies using libchop in terms of storage efficiency and
computational cost, for various types of input files.

@item Storage Tradeoffs in a Collaborative Backup Service for Mobile Devices
Ludovic Court@`es et al., 2006,
@url{http://hal.archives-ouvertes.fr/@/hal-00187069/en/}.  This paper
provides a summary of the above.

@end table

Other readings:

@table @asis

@item @url{http://plan9.bell-labs.com/@/sys/@/doc/@/venti/@/venti.html, Venti: a new approach to archival storage}
Sean Quinlan and Sean Dorward.

@end table


@c *********************************************************************
@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl-1.3.texi

@c *********************************************************************
@node Concept Index
@unnumbered Concept Index
@printindex cp

@node Function Index
@unnumbered Function Index
@printindex fn

@c @node Variable Index
@c @unnumbered Variable Index
@c @printindex vr

@bye

@c Local Variables:
@c ispell-local-dictionary: "american";
@c End:

@c  LocalWords:  deserialization libchop deserializing
