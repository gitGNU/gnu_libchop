\input texinfo  @c -*-texinfo-*-

@c %**start of header
@setfilename libchop.info
@settitle Libchop File Chopping Library
@footnotestyle end
@setchapternewpage odd
@c %**end of header

@set EDITION 1
@set VERSION 0.2
@c @set UPDATED 2005-04-26


@ifinfo
@dircategory Development
@direntry
* libchop: (libchop).      The libchop data storage library.
@end direntry

This file documents libchop.

Copyright @copyright{} 2010  Ludovic Court@`es
Copyright @copyright{} 2005, 2006  Centre National de la Recherche Scientifique (LAAS-CNRS)

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts.  A copy of the license is included in the section entitled ``GNU
Free Documentation License''.
@end quotation
@end ifinfo

@titlepage
@title The Libchop Data Storage Library
@subtitle for Libchop @value{VERSION}
@author Ludovic Courtès

@page
@vskip 0pt plus 1filll
Edition @value{EDITION} @*
@value{UPDATED} @*

Copyright @copyright{} 2010  Ludovic Court@`es
Copyright @copyright{} 2005, 2006  Centre National de la Recherche Scientifique (LAAS-CNRS)

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts.  A copy of the license is included in the section entitled ``GNU
Free Documentation License''.
@end quotation
@end titlepage

@contents

@c *********************************************************************
@node Top
@top Libchop

This document describes libchop version @value{VERSION}.

@menu
* Introduction::                Rationale and overview.
* API Reference::               Using libchop from C.
* Object System::               Object, classes, serialization, etc.
* Utilities::                   Command-line interface to libchop.
* Guile Bindings::              Using libchop from GNU Guile.
* References::                  Worthy readings.
* GNU Free Documentation License::  The license of this manual
* Concept Index::               Concepts.
* Function Index::              Functions.
@end menu

@node Introduction
@chapter Introduction

Libchop is a file hashing, ciphering, and indexing library.  In a
nutshell, libchop provides mechanisms to:

@enumerate
@item
cut a file into pieces, store each of these blocks into a block store,
and return an @dfn{abstract index} containing all the information
necessary to retrieve the file;

@item
restore (rebuild) a file based on an abstract index, reading blocks from
one (or several) block stores and decoding them according to the methods
specified by the abstract index.
@end enumerate

Libchop decomposes these task with a fine grain, providing generic
interfaces for each of the sub-tasks involved.  It also comes with
several implementations of each of these interfaces, allowing various
storage strategies to be quickly experimented and compared.
Implementations of these interfaces provide storage techniques such as
content-based addressing, content-hash keys, lossless compression, and
similarity detection.

The following section gives an overview of the various interfaces and
how they fit together.  The next one will give an insight on typical
use cases of the techniques and algorithms implemented by Libchop.

@menu
* Overview::                    
* Use Cases::                   
@end menu

@node Overview
@section Overview

@cindex pipeline
Libchop, as a file chopping and indexing framework, defines several
fine-grain interfaces for that purpose.  Objects implementing those
interfaces may be composed together to form a @dfn{file chopping
pipeline}: the input of this pipeline are the raw contents of a file,
and its output is a set of data blocks and an @dfn{index handle} that
suffices to restore the file contents from those blocks.

The interfaces that allow components to interact altogether within
this framework are the following:

@itemize
@cindex stream
@item the @dfn{stream} interface, which delivers input data (e.g. file
contents) as a stream;
@cindex chopper
@item the @dfn{chopper} interface, given an input stream, splits this
input and returns block(s);
@cindex block indexer
@item the @dfn{block indexer} (resp. the @dfn{block fetcher}) interface which
allows to name and store a single block of data (resp. to retrieve a
single block of data given its name);
@cindex stream indexer
@cindex indexer
@item the @dfn{stream indexer} interface which allows to name and
store a whole byte stream cut into pieces (resp. to retrieve a byte
stream given its name and a block store);
@cindex block store
@cindex store
@item the @dfn{block store} interface which allows to store single
data blocks under a specific name (or to restore a single block given
its name).
@end itemize

Typically, the data flow in a stream indexing pipeline will look like
this:

@verbatim
                       ,--  block indexer --.
                       |         ^          |
                       |         |          |
stream ----> chopper --+-> stream indexer --+-> block store
@end verbatim

It is worth noting that the block indexer has a central position
because it both stores data block directly to the block store, and
produces meta-data (individual block indices) which is fed back to the
stream indexer in order to be eventually stored and indexed as if it
were ``normal'' data.

When doing the opposite operation, i.e. restoring a data stream, the
data flow looks like this:

@verbatim
                        ,-------------------.
                        |                   |
                        v                   |
block store ----> block fetcher ----> stream indexer ----> byte stream
@end verbatim

Here, the stream ``indexer'' (actually a stream
@emph{fetcher}@footnote{For design reasons, there is actually one
interface (class) for both the stream indexer and the stream fetcher,
while the block indexer and block fetcher interfaces are represented
by two separate classes.  Conceptually, indexing and fetching are
really two distinct functions in both cases.  They are, however,
@emph{dual} functions, and may share code.}) is controlled by the user
(who provided the @dfn{index handle} of the stream to be retrieved).
The stream indexer, in turns, controls the block fetcher in order to
retrieve individual blocks from the underlying block store.

For each of these interfaces, libchop provides several
implementations.  Therefore, the user can conveniently choose the
pipeline configuration that fits them best.

@cindex filter
@cindex filtered stream
@cindex filtered block store
@findex chop_filtered_stream_open
@findex chop_filtered_store_open
Additionally, it is sometimes useful to @dfn{filter} input streams or
input/output blocks, pretty much in the same way one uses ``pipes''
under Unix.  Libchop provides a number of filters that may be used for
this purpose, such as zlib/bz2 unzip/zip filters, or public-key
ciphering filters.  The user can then create a filtered stream (via
@code{chop_filtered_stream_open ()}) or a filtered block store (via
@code{chop_filtered_store_open ()}) in order to make use of them.

@node Use Cases
@section Use Cases

File chopping and indexing techniques are used in a wide range of
applications, including distributed storage, peer-to-peer file
sharing, archival, backup, and revision control.  Each of these
classes of application has specific requirements, and each particular
design in these classes adds its own specificities.

Anonymous peer-to-peer file sharing systems like GNUnet and FreeNet
both use the same particular configurations of the above pipeline.
Roughly, they use a fixed-size stream chopper (e.g. in GNUnet 0.7,
input files are chopped into 32 kB blocks) and some form of a
CHK@footnote{@dfn{CHK} means ``content-hash key''.  See @xref{Stream
Choppers}, for details.} block indexer.  GNUnet uses a tree stream
indexer.  In GNUnet, this whole encoding configuration is called
@dfn{ECRS}.  Obviously, both projects use a completely distributed
block store underneath.

The @dfn{write-once read many} (WORM) archival system Venti (used in
Plan 9) uses a tree indexer and a content-based block indexer.  Venti
chops files into fixed-size blocks.

Recent revision control systems (like Monotone, GIT, Mercurial,
@code{revc}, Bazaar 2, etc.) do not cut file into pieces.  Therefore,
they do not require a stream indexer since each input file yields one
block.  However, they index files using a content-based block indexer,
which guarantees single-instance storage and integrity verification.

Rsync uses content-based indexing as well in order to reduce the
amount of data to be transferred when synchronizing copies of a set of
files across different machines over the network.


@c *********************************************************************
@node API Reference
@chapter API Reference

@menu
* Input Streams::               
* Stream Choppers::             
* Block Stores::                
* Block Indexers & Fetchers::   
* Stream Indexers::             
* Filters::                     
@end menu

@node Input Streams
@section Input Streams

The @code{chop_stream_t} type provides a simple interface to input byte
streams.  Data is read on-demand using the @code{chop_stream_read ()}
function:

@deftp {Type} chop_stream_t
The type of an input byte stream.
@end deftp

@deftypevar chop_class_t chop_stream_class
The class object for instances of type @code{chop_stream_t}.
@end deftypevar

@deftypefun chop_error_t chop_stream_read (chop_stream_t *@var{stream}, char *@var{buffer}, size_t @var{size}, size_t *@var{read})
Read at most @var{size} bytes from @var{stream} into @var{buffer}.  On
failure, return an error code (non-zero).  Otherwise, return in
@var{read} the number of bytes actually read.
@end deftypefun

@deftypefun size_t chop_stream_preferred_block_size (const chop_stream_t *@var{stream})
Return the preferred block size for reading @var{stream}.  This gives
callers, such as choppers, a hint, which may improve read performance.
@end deftypefun

@subsection Input Stream Classes

Several classes implement @code{chop_stream_t}:

@deftypevar chop_class_t chop_file_stream_class
@deftypevarx chop_class_t chop_mem_stream_class
@deftypevarx chop_class_t chop_filtered_stream_class
Classes that inherit from @var{chop_stream_class}.
@end deftypevar

These classes implement input streams backed by files, in-memory byte
arrays, or by another stream passed through a filter (@pxref{Filters}).

To create instances of these classes, use the constructors below.

@deftypefun chop_error_t chop_file_stream_open (const char *@var{path}, chop_stream_t *@var{stream})
Open file located at @var{path} and initialize @var{stream} as a file
stream representing this file.  @var{stream} has to point to a
large-enough memory area to hold an object whose class is
@code{chop_file_stream_class}.
@end deftypefun

@deftypefun void chop_mem_stream_open (const char *@var{base}, size_t @var{size}, void (*@var{free_func}) (void *), chop_stream_t *@var{stream})
Open a memory-backed stream, i.e. a stream whose input is read from
@var{base} which is @var{size} byte-long.  If @var{free_func} is not
@code{NULL}, it is called upon closing @var{stream}.
@end deftypefun

@deftypefun chop_error_t chop_filtered_stream_open (chop_stream_t *@var{backend}, chop_proxy_semantics_t @var{bps}, chop_filter_t *@var{filter}, int @var{owns_filter}, chop_stream_t *@var{stream})
Initialize @var{stream} as a filtered stream that reads input data from
@var{backend} through @var{filter}.  @var{bps} defines the semantics of
@var{stream} as a proxy of @var{backend} (whether @var{backend} should
eventually be destroyed, etc.).  Similarly, if @var{owns_filter} is
true, then closing @var{stream} will destroy @var{filter}.
@end deftypefun

@node Stream Choppers
@section Stream Choppers

@node Block Stores
@section Block Stores

@node Block Indexers & Fetchers
@section Block Indexers & Fetchers

@node Stream Indexers
@section Stream Indexers

@node Filters
@section Filters


@c *********************************************************************
@node Object System
@chapter Object System

@cindex object system
Libchop comes with its own lightweight reflexive object system defined
in the @code{<chop/objects.h>} header file.  Given that it is a
reflexive object system, type information is available at run-time.
While this may seem, at first, like a lot of overhead for little
benefits, it certainly offers some advantages compared to Glib's
object system.

@cindex binary compatibility
In particular, libchop's object system can be used to provide binary
compatibility with almost no gratuitous overhead: the size of a given
class' instances can be known at run-time, which allows for caller
allocation.  Callers can allocate objects of a given class as they
prefer (e.g. on the stack) while still having binary compatilibity
accross changes of a class' fields layout.

This is, a lightweight approach compared to the Glib family of
libraries where binary compatibility is achieved at the cost of
removing the possibility for caller memory allocation: constructors do
not only initialize an object, they also allocate its storage on the
heap.

That said, libchop's object system have a lot in common with C++,
except that it cannot benefit from the compiler's help (e.g. to manage
type inheritance at compile-time, to automatically generate the
invocation of an object's destructor when needed, etc.).  On the other
hand, it provides real reflection and gives more flexibility.

Let's have a closer look at it.

@menu
* Declaring and Defining a Class::  
* Instantiating an Object::     
* Cloning an Object::           
* Testing Objects for Equality::  
* Serializing and Deserializing an Object::  
@end menu

@node Declaring and Defining a Class
@section Declaring and Defining a Class

@cindex class

At run-time, libchop classes are represented by @code{chop_class_t}
objects.  The canonical naming scheme for classes is the following.
Let @code{chbouib} be a libchop class:

@itemize
@item its C type is named @code{chop_chbouib_t};
@item its run-time representation is a global @code{chop_class_t}
object named @code{chop_chbouib_class}.
@end itemize

Libchop defines macros to declare and define classes while maintaining
the naming scheme in a consistent way:

@defmac CHOP_DECLARE_RT_CLASS (name, parent_name, fields)
Declare a class named @var{name}, that is declare the type
@code{chop_NAME_t} and the global variable @code{chop_NAME_class}.
@var{fields} should be a list of fields (as in a @code{struct}
definition).  Note that libchop classes must always inherit (directly
or not) the @code{object} class.

Example:

@example
CHOP_DECLARE_RT_CLASS (chbouib, object,
                       int x;
                       float y;);
@end example

@end defmac

@defmac CHOP_DEFINE_RT_CLASS (name, parent_name, ctor, dtor, copy, equalp, serial, dserial)
Once the class named @var{name} has been declared, this macro defines
it as being a sub-class of the class named @var{parent_name} (this
must be the same name as the one used in the declaration!), with
constructor @var{ctor} and destructor @var{dtor} (both are optional),
and with copy constructor @var{copy} and equality predicate
@var{equalp} (both optional too).  Finally, @var{serial} is a pointer
to a serializer and @var{dserial} and pointer to a deserializer which
may both be @code{NULL} as well.
@end defmac

See the @code{<chop/objects.h>} for details.

@node Instantiating an Object
@section Instantiating an Object

Constructors, in libchop, do not allocate memory to store objects:
they simple @emph{initialize} objects.  Therefore, memory must be
allocated to store a given an object @emph{before} its constructor is
called.  Run-time type information turns out to be helpful here: each
@code{chop_class_t} object contains information about the amount of
memory needed to store an instance of it.

@deftypefun size_t chop_class_instance_size (const chop_class_t *class)
Return the size, in bytes, of instances of class @var{class}.
@end deftypefun

@defmac chop_class_alloca_instance (class)
Return a pointer to a memory area large enough to store an instance of
@var{class}.  This macro uses @code{alloca} to allocate storage on the
stack (see @inforef{Variable Size Automatic, the GNU libc manual,
libc}, for details).
@end defmac

@deftypefun chop_error_t chop_object_initialize (chop_object_t *object, const chop_class_t *class)
Initialize @var{object} as an instance of class @var{class}, thus
invoking the constructor of @var{class} and the one of its parent
classes.

As a user, you will not usually call this function directly.  Instead,
you will call a particular constructor for @var{class} that can take
additional arguments (e.g. @code{chop_file_stream_open ()}) and which
will in turn call this function behind the scenes.
@end deftypefun

@deftypefun void chop_object_destroy (chop_object_t *object)
Destroy @var{object}, that is deallocate resources associated to it.
Note that it does not deallocate the memory where @var{object} is
stored.
@end deftypefun

It is important to note that all libchop objects must be destroyed
using @code{chop_object_destroy ()}, regardless of where they are
stored in memory.

Another way to instantiate an object is described in @xref{Cloning an
Object}.


@node Cloning an Object
@section Cloning an Object

@cindex deep copy
@cindex clone
Libchop's object system allows @dfn{deep copies} or @dfn{cloning} of
objects.  Classes, however, may choose to not implement this feature.

@deftypefun chop_error_t chop_object_copy (const chop_object_t *source, chop_object_t *dest)
Clone the object pointed to by @var{source} into @var{dest}.  As
usual, @var{dest} must point to an (uninitialized) memory area large
enough to hold an instance of @var{source}'s class.  If @var{source}'s
class does not implement cloning, then a default ``shallow'' copy is
performed.

Note that, in any case, the copy constructors of the whole class
hierarchy of @var{source} are invoked, starting from the higher one,
just like for a regular instantiation (@pxref{Instantiating an
Object}).
@end deftypefun


@node Testing Objects for Equality
@section Testing Objects for Equality

@cindex equality predicate
Testing whether two objects are equal or not may be dependant on the
implementation of their classes.  Classes may implement an
@dfn{equality predicate} that can be used two compare two
instances@footnote{This is similar to Scheme's @code{equal?}
vs. @code{eq?} @inforef{Equivalence predicates, R5RS Equivalence
Predicates, r5rs}.}.

@deftypefun int chop_object_equal (const chop_object_t *o1, const chop_object_t *o2)
Return true (non-zero) if objects @var{o1} and @var{o2} are equal.  If
both objects are instances of the same class but that class does not
define an equality predicate, they will only be considered equal if
and only if @code{@var{o1} == @var{o2}}, from a pointer arithmetic
viewpoint.
@end deftypefun


@node Serializing and Deserializing an Object
@section Serializing and Deserializing an Object

@cindex serialization
@cindex deserialization
Classes in libchop may implement a @dfn{serialization} and a
@dfn{deserialization} methods---these methods may be specified at
class definition time (@pxref{Declaring and Defining a Class}).
A serialization method basically converts an object into a portable
representation of its state as a byte stream.  The deserialization
operation does the opposite.

The @code{chop_serial_method_t} type defines two standard
serialization/deserialization methods:

@table @code
@item CHOP_SERIAL_ASCII
An object is serialized using only ASCII characters.  This yields
human-readable representations.
@item CHOP_SERIAL_BINARY
An object is serialized using as a byte stream where each byte can
have any value.  This usually yields to significantly more compact
representations.
@end table

@deftypefun chop_error_t chop_object_serialize (const chop_object_t *object, chop_serial_method_t method, chop_buffer_t *buffer)
Serialize @var{object} according to serialization method @var{method}
into @var{buffer}.  If no serializer exists for @var{object}'s class,
@code{CHOP_ERR_NOT_IMPL} is returned.  On success, zero is returned.
@end deftypefun

@deftypefun chop_error_t chop_object_deserialize (chop_object_t *object, const chop_class_t *class, chop_serial_method_t method, const char *buffer, size_t size, size_t *bytes_read)
Initialize @var{object}, which is expected to be of type @var{class},
by deserializing @var{buffer} (of @var{size} bytes), according to
@var{method}.  On success, zero is returned and @var{object} is
initialized.  Otherwise, @var{object} is left in an undefined state.
On success, @var{bytes_read} is set to the number of bytes that were
read from @var{buffer} in order to deserialize @var{object}.
@end deftypefun


@c *********************************************************************
@node Utilities
@chapter Utilities

Libchop comes with a number of utilities that exercise all its API.
Using them is actually a good way to become familiar with libchop's
interfaces and their implementations.

The first tool, @code{chop-archiver}, exposes all of libchop's storage
pipeline, which makes it the main entry point to libchop from the
command line.  The @code{chop-block-server} tool implements a dumb
@dfn{block server}, which listens to remote procedure calls (RPCs) to
read and write data blocks.

@menu
* Invoking chop-archiver::      Storing and restoring data using libchop.
* Invoking chop-block-server::  Remote data block storage.
@end menu

@node Invoking chop-archiver
@section Invoking @code{chop-archiver}

@node Invoking chop-block-server
@section Invoking @code{chop-block-server}

The @code{chop-block-server} tool is an ONC RPC server that serves
requests from the network to read and write data blocks.  It it similar
in spirit to Plan 9's Venti (@pxref{References, Venti}).  By default, it
is completely oblivious to the encoding and naming scheme of incoming
data blocks: it doesn't know what block indexer was used to index them,
doesn't require content-based indexing, and of course doesn't know how
these data blocks relate to each other.

The server is invoked like this:

@example
chop-block-server [@var{options}] @var{local-block-store}
@end example

This command starts a block store server listening to block store remote
procedure calls (RPCs) and applying them to the store from file
@var{local-block-store} (the type of store in this file is determined by
the @code{--store} option; see below.)  @var{options} can contain any
options from the following list:

@table @option
@item --help
Print a summary of the command-line options and exit.

@item --version
Print the version number of libchop and exit.

@item --address=@var{address}
@itemx -a @var{address}
Bind to @var{address} and listen to connections there.

@item --port=@var{port}
@itemx -p @var{port}
Run the service on port @var{port}.

@item --protocol=@var{proto}
@itemx -P @var{proto}
Serve RPCs over PROTO, either @code{tcp} or @code{udp}.

@item --no-collision-check
@itemx -C
Turn off block/key collision checks.  By default, when a request to
write a block under a given key is received, @code{chop-block-server}
returns an error if there's already a block associated with that key and
that block differs from the new one.

@item --enforce-hash=@var{algo}
@itemx -H
Enforce content-hash algorithm @var{algo}.  That is, return an error if
the key under which a block is to be written is not the @var{algo} hash
of this block.

@item --zip[=@var{zip-type}]
@itemx -z[@var{zip-type}]
Pass data blocks through a @var{zip-type} filter to compress
(resp. decompress) data when writing (resp. reading) to (resp. from) the
block store.  @var{zip-type} may be one of @code{zlib}, @code{bzip2}, or
@code{lzo}, for instance.

@item --service-name=@var{name}
@itemx -s @var{name}
Choose @var{name} as the service name to be published via Avahi.  This
option is only available when Avahi was detected at configure time.

@item --no-publication
@itemx -n
Turn off service publication on the LAN via Avahi.  This option is only
available when Avahi was detected at configure time.

@item --tls
@itemx -t
Use RPCs over TLS (recommended).  This option is only available when
GnuTLS was detected at configure time.

@item --openpgp-pubkey=@var{pubkey-file}
@itemx -o @var{pubkey-file}
@itemx --openpgp-privkey=@var{privkey-file}
@itemx -O @var{privkey-file}
Use the OpenPGP public key from @var{pubkey-file} and the corresponding
private key from @var{privkey-file} for TLS authentication.  These files
must contain a base64-encoded OpenPGP key.  These options are available
when GnuTLS was detected at configure time.

@item --store=@var{class}
@itemx -S @var{class}
Use @var{class} as the underlying file-based block
store (@pxref{Block Stores}).

@item --debug
@itemx -d
Produce debugging output and use a dummy block store (i.e., a block
store that does nothing but print messages).

@item --verbose
@itemx -v
Produce verbose output.

@end table


@c *********************************************************************
@node Guile Bindings
@chapter Guile Bindings

@c *********************************************************************
@node References
@chapter References

@table @asis

@item Plan 9's Venti archival storage server
@url{http://plan9.bell-labs.com/magic/man2html/8/venti}

@item Venti: a new approach to archival storage
Sean Quinlan and Sean Dorward,
@url{http://plan9.bell-labs.com/sys/doc/venti/venti.html}

@end table


@c *********************************************************************
@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl-1.3.texi

@c *********************************************************************
@node Concept Index
@unnumbered Concept Index
@printindex cp

@node Function Index
@unnumbered Function Index
@printindex fn

@c @node Variable Index
@c @unnumbered Variable Index
@c @printindex vr

@bye

@c Local Variables:
@c ispell-local-dictionary: "american";
@c End:

@c  LocalWords:  deserialization libchop deserializing
